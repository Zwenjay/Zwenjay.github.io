<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[242 Valid Anagram]]></title>
    <url>%2F2017%2F09%2F02%2F242-Valid-Anagram%2F</url>
    <content type="text"><![CDATA[Question Given two strings s and t, write a function to determine if t is an anagram of s. For example,s = “anagram”, t = “nagaram”, return true.s = “rat”, t = “car”, return false. Note: You may assume the string contains only lowercase alphabets. Solution 1 Alphabet ArraySince there are only 26 alphabet, we could build an alphabet array and store times eacht alphabet appears. Code1234567891011121314class Solution &#123; public boolean isAnagram(String s, String t) &#123; int[] alphbet = new int[26]; for(char ch : s.toCharArray()) alphbet[ch-'a']++; for(char ch : t.toCharArray()) alphbet[ch-'a']--; for(int x : alphbet) if(x != 0) return false; return true; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Sort</tag>
        <tag>Faceboook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[202 Happy Number]]></title>
    <url>%2F2017%2F09%2F02%2F202-Happy-Number%2F</url>
    <content type="text"><![CDATA[Question Write an algorithm to determine if a number is “happy”. A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers. Example: 19 is a happy number 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Solution 1 Math SolutionIt’s just too tricky. Every number will be less than 6 sometiome Every number became 2-6 are not happy. Code123456789101112131415161718class Solution &#123; public boolean isHappy(int n) &#123; while(n &gt; 6)&#123; n = generateHappy(n); &#125; return n == 1; &#125; private int generateHappy(int n)&#123; int sum = 0; while( n&gt;0 )&#123; sum += (n%10) * (n%10); n/=10; &#125; return sum; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(1) Solution 2 Two Pointersset fast and slow Code1234567891011121314151617181920212223class Solution &#123; public boolean isHappy(int n) &#123; int slow = generateHappy(n); int fast = generateHappy(n); fast = generateHappy(fast); while(fast != slow)&#123; slow = generateHappy(slow); fast = generateHappy(fast); fast = generateHappy(fast); &#125; return slow == 1; &#125; private int generateHappy(int n)&#123; int sum = 0; while( n&gt;0 )&#123; sum += (n%10) * (n%10); n/=10; &#125; return sum; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[24 Swap Nodes in Pairs]]></title>
    <url>%2F2017%2F09%2F02%2F24-Swap-Nodes-in-Pairs%2F</url>
    <content type="text"><![CDATA[Question Given a linked list, swap every two adjacent nodes and return its head. For example,Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. Solution 1 Swap Nodes12345678910111213141516class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode dumpy = new ListNode(0), temp, cur; dumpy.next = head; cur = dumpy; while(cur != null &amp;&amp; cur.next != null &amp;&amp; cur.next.next != null)&#123; temp = cur.next; cur.next = temp.next; temp.next = cur.next.next; cur.next.next = temp; cur = temp; &#125; return dumpy.next; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[39 Combination Sum]]></title>
    <url>%2F2017%2F09%2F02%2F39-Combination-Sum%2F</url>
    <content type="text"><![CDATA[Question Given a set of candidate numbers (C) (without duplicates) and a target number (T), find all unique combinations in C where the candidate numbers sums to T. The same repeated number may be chosen from C unlimited number of times. Note: All numbers (including target) will be positive integers. The solution set must not contain duplicate combinations. For example, given candidate set [2, 3, 6, 7] and target 7,A solution set is: [ [7], [2, 2, 3] ] Solution 1 BacktrackingJust normal backtracking method. One thing: since it could use same numbers more than one times, the position in next backtracking should be i rather than i+1 Code123456789101112131415161718192021class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(res, target, new ArrayList&lt;Integer&gt;(), candidates, 0); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, int target, List&lt;Integer&gt; temp, int[] candidates, int pos)&#123; if(target == 0)&#123; res.add(new ArrayList&lt;Integer&gt;(temp)); return; &#125; if(target &lt; 0) return; for(int i = pos; i &lt; candidates.length; i++)&#123; temp.add(candidates[i]); backtracking(res, target - candidates[i], temp, candidates, i); temp.remove(temp.size()-1); &#125; &#125;&#125; T&amp;S AnalysisTime: Hard to calculate, related to the size of nums, those numbers in set and the target number. Space:: Same as above, because of use of recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[22 Generate Parentheses]]></title>
    <url>%2F2017%2F09%2F01%2F22-Generate-Parentheses%2F</url>
    <content type="text"><![CDATA[Question Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses. For example, given n = 3, a solution set is: [ "((()))", "(()())", "(())()", "()(())", "()()()" ] Solution 1 Backtracking12345678910111213141516171819class Solution &#123; public List&lt;String&gt; generateParenthesis(int n) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); backtracking(n, res, "", 0, 0); return res; &#125; private void backtracking(int n, List&lt;String&gt; res, String s, int left, int right)&#123; if(right == n)&#123; res.add(s); return; &#125; if(left &lt; n)&#123; backtracking(n, res, s + "(", left+1 , right); &#125; if(right &lt; left) backtracking(n, res, s + ")", left, right +1); &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>String</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[402 Remove K Digits]]></title>
    <url>%2F2017%2F09%2F01%2F402-Remove-K-Digits%2F</url>
    <content type="text"><![CDATA[Question Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible. Example 1: Input: num = "1432219", k = 3 Output: "1219" Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest. Example 2: Input: num = "10200", k = 1 Output: "200" Explanation: Remove the leading 1 and the number is 200. Note that the output must not contain leading zeroes. Example 3: Input: num = "10", k = 2 Output: "0" Explanation: Remove all the digits from the number and it is left with nothing which is 0. Solution 1 Delete Larger OneIf current num is smaller than its former, delete the former and continue comparing until k = 0 or i = 0. Code123456789101112131415161718192021222324class Solution &#123; public String removeKdigits(String num, int k) &#123; int l = num.length(); int i = 1; while(i &lt; l)&#123; while( i &gt;= 1 &amp;&amp;l&gt;1 &amp;&amp; num.charAt(i) &lt; num.charAt(i-1) &amp;&amp; k&gt;0)&#123; num = num.substring(0, i-1) + num.substring(i, l); l--; k--; i--; &#125; if(k == 0 || l==1) break; i++; &#125; i = 0; while(i &lt; l &amp;&amp; num.charAt(i) == '0') i++; if(i &gt;= l-k) return "0"; return num.substring(i, l-k); &#125;&#125; T&amp;S AnalysisTime: O(N), it seems like o(N^2), but in fact num will get shorter. And every node are visited constant times. Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Stack</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[231 Power of Two]]></title>
    <url>%2F2017%2F09%2F01%2F231-Power-of-Two%2F</url>
    <content type="text"><![CDATA[Question Given an integer, write a function to determine if it is a power of two. Solution 1 Mathnormal solution. 123456789101112&gt;class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n &lt;= 0) return false; while(n &gt; 1)&#123; if(n % 2 == 1) return false; n = n &gt;&gt; 1; &#125; return true; &#125;&#125; T&amp;S AnalysisTime: O(n)__Space: O(1) Solution 2 Bit manipulateBit manipulate solution, very fast. Code1234567class Solution &#123; public boolean isPowerOfTwo(int n) &#123; if(n &lt;= 0) return false; return (n &amp; (n-1))==0 ; &#125;&#125; T&amp;S AnalysisTime: O(1) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Math</tag>
        <tag>Bit Manipulate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[382 Linked List Random Node]]></title>
    <url>%2F2017%2F08%2F31%2F382-Linked-List-Random-Node%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list, return a random node’s value from the linked list. Each node must have the same probability of being chosen. Follow up: What if the linked list is extremely large and its length is unknown to you? Could you solve this efficiently without using extra space? Example: // Init a singly linked list [1,2,3].ListNode head = new ListNode(1);head.next = new ListNode(2);head.next.next = new ListNode(3);Solution solution = new Solution(head); // getRandom() should return either 1, 2, or 3 randomly. Each element should have equal probability of returning.solution.getRandom(); Solution 1 Use Reservoir SamplingRandomly choose the k-th number as 1/k. Code:123456789101112131415161718192021222324class Solution &#123; /** @param head The linked list's head. Note that the head is guaranteed to be not null, so it contains at least one node. */ ListNode head; public Solution(ListNode head) &#123; this.head = head; &#125; /** Returns a random node's value. */ public int getRandom() &#123; ListNode cur = head; int res = head.val, i=2; cur = cur.next; while(cur != null)&#123; if(Math.random() &lt;= 1.0/i) res = cur.val; i++; cur = cur.next; &#125; return res; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Reservoir Sampling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[51 Spiral Matrix]]></title>
    <url>%2F2017%2F08%2F31%2F51-Spiral-Matrix%2F</url>
    <content type="text"><![CDATA[Question Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order. For example,Given the following matrix: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] You should return [1,2,3,6,9,8,7,4,5]. Solution 1 Just go as it said###Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Solution &#123; public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123; int i = 0, j = 0; int top = 0, bottom = matrix.length-1; if(bottom &lt; 0) return new ArrayList&lt;Integer&gt;(); int left = 0, right = matrix[0].length-1; List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); while(true)&#123; if(i == top)&#123; while(j &lt;= right)&#123; res.add(matrix[i][j]); j++; &#125; j--; i++; top++; if(top &gt; bottom) return res; &#125; if(j == right )&#123; while(i &lt;= bottom)&#123; res.add(matrix[i][j]); i++; &#125; i--; j--; right--; if(right&lt;left) return res; &#125; if(i == bottom)&#123; while(j &gt;= left)&#123; res.add(matrix[i][j]); j --; &#125; j++; i--; bottom--; if(bottom &lt; top) return res; &#125; if(j == left)&#123; while(i &gt;= top)&#123; res.add(matrix[i][j]); i --; &#125; i++; j++; left++; if(left &gt; right) return res; &#125; &#125; &#125;&#125; T&amp;S AnalysisTime: O(N) Space: O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[133 Clone Graph]]></title>
    <url>%2F2017%2F08%2F31%2F133-Clone-Graph%2F</url>
    <content type="text"><![CDATA[Question Clone an undirected graph. Each node in the graph contains a label and a list of its neighbors. OJ’s undirected graph serialization:Nodes are labeled uniquely. We use # as a separator for each node, and , as a separator for node label and each neighbor of the node.As an example, consider the serialized graph {0,1,2#1,2#2,2}. The graph has a total of three nodes, and therefore contains three parts as separated by #. First node is labeled as 0. Connect node 0 to both nodes 1 and 2. Second node is labeled as 1. Connect node 1 to node 2. Third node is labeled as 2. Connect node 2 to node 2 (itself), thus forming a self-cycle. Visually, the graph looks like the following: 1 / \ / \ 0 --- 2 / \ \_/ Solution 1 BFSUse BFS, one set to stroe those are already visited, and one map to map the relation between original node to current node. Code123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; List&lt;UndirectedGraphNode&gt; q = new ArrayList&lt;UndirectedGraphNode&gt;(); HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt; map = new HashMap&lt;UndirectedGraphNode, UndirectedGraphNode&gt;(); Set&lt;Integer&gt; visited = new HashSet&lt;Integer&gt;(); UndirectedGraphNode res, cur; if(node == null) return null; q.add(node); res = new UndirectedGraphNode(node.label); cur = res; q.add(cur); while(q.size()&gt;0)&#123; UndirectedGraphNode x = q.remove(0); cur = q.remove(0); if(visited.contains(x.label)) continue; List&lt;UndirectedGraphNode&gt; nei = x.neighbors; map.put(x, cur); visited.add(x.label); for(int i =0; i &lt; nei.size(); i++)&#123; if(!map.containsKey(nei.get(i)))&#123; UndirectedGraphNode tempNode = new UndirectedGraphNode((nei.get(i).label)); cur.neighbors.add(tempNode); map.put(nei.get(i), tempNode); &#125;else&#123; cur.neighbors.add(map.get(nei.get(i))); &#125; if(!visited.contains(nei.get(i).label))&#123; System.out.println(1); q.add(nei.get(i)); q.add(cur.neighbors.get(i)); &#125; &#125; &#125; return res; &#125;&#125; T&amp;S AnalysisTime: O(node+edge) Space: O(n) for queue, set and map. Solution 2 DFSCode123456789101112131415161718192021public class Solution &#123; HashMap&lt;Integer, UndirectedGraphNode&gt; map = new HashMap&lt;Integer, UndirectedGraphNode&gt;(); public UndirectedGraphNode cloneGraph(UndirectedGraphNode node) &#123; return clone(node); &#125; private UndirectedGraphNode clone(UndirectedGraphNode node)&#123; if(node == null) return null; if(map.containsKey(node.label))&#123; return map.get(node.label); &#125; UndirectedGraphNode cp = new UndirectedGraphNode(node.label); map.put(cp.label, cp); for(UndirectedGraphNode n : node.neighbors)&#123; cp.neighbors.add(clone(n)); &#125; return cp; &#125;&#125; T&amp;S AnalysisTime: O(node+edge) Space: O(node+edge) for recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[236 Lowest Common Ancestor of a Binary Tree]]></title>
    <url>%2F2017%2F08%2F30%2F236-Lowest-Common-Ancestor-of-a-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow a node to be a descendant of itself).” _______3______ / \ ___5__ ___1__ / \ / \ 6 _2 0 8 / \ 7 4 For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Solution 1 RecursionCode1234567891011121314class Solution &#123; public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123; if(root == p || root == q || root == null) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left == null) return right; if(right == null) return left; return root; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(n) for recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[98 Valid Binary Search Tree]]></title>
    <url>%2F2017%2F08%2F30%2F98-Valid-Binary-Search-Tree%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, determine if it is a valid binary search tree (BST). Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Example 1: 2 / \ 1 3 Binary tree [2,1,3], return true. Example 2: 1 / \ 2 3 Binary tree [1,2,3], return false. Solution 1 Morris Order Traversal1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public boolean isValidBST(TreeNode root) &#123; TreeNode cur = root, p; boolean first = true; int val=0; while(cur != null)&#123; if(cur.left == null)&#123; if(first)&#123; val = cur.val; first = false; cur = cur.right; continue; &#125; if(cur.val &lt;= val) return false; val = cur.val; cur = cur.right; &#125;else&#123; p = cur.left; while(p.right != null &amp;&amp; p.right != cur) p = p.right; if(p.right == null)&#123; p.right = cur; cur = cur.left; &#125;else&#123; if(first)&#123; val = cur.val; first = false; p.right = null; cur = cur.right; continue; &#125; if(cur.val &lt;= val) return false; val = cur.val; p.right = null; cur = cur.right; &#125; &#125; &#125; return true; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
        <tag>Morris Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[125 Valid Palindrome]]></title>
    <url>%2F2017%2F08%2F30%2F125-Valid-Palindrome%2F</url>
    <content type="text"><![CDATA[Question Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases. For example,“A man, a plan, a canal: Panama” is a palindrome.“race a car” is not a palindrome. Solution 1 Two PointersCode12345678910111213141516171819202122class Solution &#123; public boolean isPalindrome(String s) &#123; int i = 0, j = s.length()-1; while(i &lt; j)&#123; if(!((s.charAt(i)-'A' &lt;= 26 &amp;&amp; s.charAt(i)-'A'&gt;=0) || (s.charAt(i)-'a' &lt;= 26 &amp;&amp; s.charAt(i)-'a' &gt;= 0) ||(s.charAt(i)-'0'&gt;=0 &amp;&amp; s.charAt(i)-'0'&lt;=9)))&#123; i++; continue; &#125; if(!((s.charAt(j)-'A' &lt;= 26 &amp;&amp; s.charAt(j)-'A'&gt;=0) || (s.charAt(j)-'a' &lt;= 26 &amp;&amp; s.charAt(j)-'a' &gt;= 0) || (s.charAt(j)-'0'&gt;=0 &amp;&amp; s.charAt(j)-'0'&lt;=9)))&#123; j--; continue; &#125; char ch1 = s.charAt(i), ch2 = s.charAt(j); if(Character.toLowerCase(ch1) != Character.toLowerCase(ch2)) return false; i++; j--; &#125; return true; &#125;&#125; T&amp;S AnalysisTime: O(N) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[78 Subsets]]></title>
    <url>%2F2017%2F08%2F30%2F78-Subsets%2F</url>
    <content type="text"><![CDATA[Question Given a set of distinct integers, nums, return all possible subsets. Note: The solution set must not contain duplicate subsets. For example,If nums = [1,2,3], a solution is: [ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], [] ] Solution 1 BacktrackingSelect one in the nums and repeat this operation until the last one. Each time chosen the number, turn to the next num and backtracking it, after recursion tracking, remove the last element. Code1234567891011121314151617class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); backtracking(res, 0, new ArrayList&lt;Integer&gt;(), nums); return res; &#125; private void backtracking(List&lt;List&lt;Integer&gt;&gt; res, int pos, ArrayList&lt;Integer&gt; temp, int[] nums)&#123; res.add(new ArrayList(temp)); for(int i = pos; i&lt;nums.length; i++)&#123; temp.add(nums[i]); backtracking(res, i+1, temp, nums); temp.remove(temp.size()-1); &#125; &#125;&#125; T&amp;S AnalysisTime: O(exp(N)) Space: O(exp(N))]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Backtracking</tag>
        <tag>Bit Manipulate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[75 Sort Colors]]></title>
    <url>%2F2017%2F08%2F29%2F75-Sort-Colors%2F</url>
    <content type="text"><![CDATA[Question Given an array with n objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Solution 1 Adjust 3 timesOnly 3 values, so this method could work. Adjust 1-2, 0-2 and 0-1 positions. Code123456789101112131415161718192021222324252627282930313233class Solution &#123; public void sortColors(int[] nums) &#123; adjust(nums, 0, 2); adjust(nums, 0, 1); adjust(nums, 1, 2); &#125; private void adjust(int[] nums, int a, int b)&#123; int i = 0, j = nums.length-1; while( i &lt; j )&#123; if(nums[i] == b &amp;&amp; nums[j] == a)&#123; swap(nums, i, j); i++; j--; if(i&gt;=j) break; &#125; if(nums[i] != b) i++; if(nums[j] !=a) j--; &#125; &#125; private void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(1) Solution 2 sweep 0 and 2This idea is to sweep 0 to left and 2 to right. Code12345678910class Solution &#123;public: void sortColors(int A[], int n) &#123; int second=n-1, zero=0; for (int i=0; i&lt;=second; i++) &#123; while (A[i]==2 &amp;&amp; i&lt;second) swap(A[i], A[second--]); while (A[i]==0 &amp;&amp; i&gt;zero) swap(A[i], A[zero++]); &#125; &#125;&#125;; T&amp;S AnalysisTime: O(n), but it scan at most twice. Space:: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[139 Word Break]]></title>
    <url>%2F2017%2F08%2F29%2F139-Word-Break%2F</url>
    <content type="text"><![CDATA[Question Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words. You may assume the dictionary does not contain duplicate words. For example, givens = “leetcode”,dict = [“leet”, “code”]. Return true because “leetcode” can be segmented as “leet code”. Solution 1 Dynamic ProgrammingCreate an array to record if the former n-th letters could be represented, if yes, find according remains. Codeclass Solution { public boolean wordBreak(String s, List&lt;String&gt; wordDict) { boolean[] judge = new boolean[s.length()+1]; judge[0] = true; for(int i = 1; i &lt;= s.length(); i++){ for(int j =0; j &lt; i; j++) if(judge[j] &amp;&amp; wordDict.contains(s.substring(j, i))) judge[i] = true; } return judge[s.length()]; } } T&amp;S AnalysisTime: It is actually O(n^2 * len(dic)) Space:: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1 Two Sum]]></title>
    <url>%2F2017%2F08%2F29%2F1-Two-Sum%2F</url>
    <content type="text"><![CDATA[Question Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Solution 1 Use HashMapBecareful of replacing keys in Hash map Code123456789101112131415class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for(int i =0; i &lt; nums.length; i++)&#123; if(map.containsKey(target - nums[i]))&#123; int[] res = new int[2]; res[0] = map.get(target - nums[i]); res[1] = i; return res; &#125; map.put(nums[i], i); &#125; return new int[2]; &#125;&#125; T&amp;S AnalysisTime: O(n) Space:: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[341 Flatten Nested List Iterator]]></title>
    <url>%2F2017%2F08%2F29%2F341-Flatten-Nested-List-Iterator%2F</url>
    <content type="text"><![CDATA[Question Given a nested list of integers, implement an iterator to flatten it. Each element is either an integer, or a list – whose elements may also be integers or other lists. Example 1:Given the list [[1,1],2,[1,1]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1]. Example 2:Given the list [1,[4,[6]]], By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6]. Solution 1 Use StackUse stack to store data, reverse the order. 1234567891011121314151617181920212223242526272829public class NestedIterator implements Iterator&lt;Integer&gt; &#123; Stack&lt;NestedInteger&gt; s = new Stack&lt;NestedInteger&gt;(); public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123; for(int i = nestedList.size() -1 ; i &gt;= 0 ; i--)&#123; s.push(nestedList.get(i)); &#125; &#125; @Override public Integer next() &#123; return s.pop().getInteger(); &#125; @Override public boolean hasNext() &#123; while(s.size()&gt;0)&#123; if(s.peek().isInteger())&#123; return true; &#125; NestedInteger cur = s.pop(); for(int i = cur.getList().size()-1; i&gt;=0; i--)&#123; s.push(cur.getList().get(i)); &#125; &#125; return false; &#125;&#125; T&amp;S AnalysisTime: Initialize: O(n) hasNext(): O(1) next(): O(n) Space:: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[173 Binary Search Tree Iterator]]></title>
    <url>%2F2017%2F08%2F29%2F173-Binary-Search-Tree-Iterator%2F</url>
    <content type="text"><![CDATA[Question Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST. Calling next() will return the next smallest number in the BST. Note: next() and hasNext() should run in average O(1) time and uses O(h) memory, where h is the height of the tree. Solution 1 Use StackThis is a easy binary tree inorder traversal with stack Code12345678910111213141516171819202122232425262728293031323334public class BSTIterator &#123; Stack &lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;(); public BSTIterator(TreeNode root) &#123; TreeNode cur = root; while(cur != null)&#123; s.push(cur); cur = cur.left; &#125; &#125; /** @return whether we have a next smallest number */ public boolean hasNext() &#123; return s.size()!=0; &#125; /** @return the next smallest number */ public int next() &#123; TreeNode cur = new TreeNode(0); if(this.hasNext())&#123; cur = s.pop(); if(cur.right != null)&#123; TreeNode p = cur.right; while(p!= null)&#123; s.push(p); p = p.left; &#125; &#125; &#125; return cur.val; &#125;&#125; T&amp;S AnalysisTime: Initialize: O(h) hasNext(): O(1) next(): O(h) Space:: O(h)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Tree</tag>
        <tag>Stack</tag>
        <tag>Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121 Best Time to Buy and Sell Stock]]></title>
    <url>%2F2017%2F08%2F29%2F121-Best-Time-to-Buy-and-Sell-Stock%2F</url>
    <content type="text"><![CDATA[Question Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4] Output: 5 max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1] Output: 0 In this case, no transaction is done, i.e. max profit = 0. Solution 1 Find the LowestDynamic programming requiring recording former information. In this problem, the information is the lowest before current day. Code1234567891011class Solution &#123; public int maxProfit(int[] prices) &#123; int lo = 0, profit = 0, i = 0; for(i = 0; i &lt; prices.length; i++)&#123; lo = prices[i] &gt; prices[lo]?lo:i; profit = Math.max(prices[i] - prices[lo], profit); &#125; return profit; &#125;&#125; T&amp;S AnalysisTime: O(n). Space: O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Dynamic Programming</tag>
        <tag>Facebook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[211 Add and Search Word-Data structure design]]></title>
    <url>%2F2017%2F08%2F28%2F211-Add-and-Search-Word-Data-structure-design%2F</url>
    <content type="text"><![CDATA[Question Design a data structure that supports the following two operations: void addWord(word) bool search(word) search(word) can search a literal word or a regular expression string containing only letters a-z or .. A . means it can represent any one letter. For example: addWord("bad") addWord("dad") addWord("mad") search("pad") -&gt; false search("bad") -&gt; true search(".ad") -&gt; true search("b..") -&gt; true Note:You may assume that all words are consist of lowercase letters a-z. Solution 1 Build a Tree StructureBuild a structure, contains a array of that structure of 26 size and an element to recode a String Code:12345678910111213141516171819202122232425262728293031323334353637383940public class WordDictionary &#123; public class TrieNode &#123; public TrieNode[] children = new TrieNode[26]; public String item = ""; &#125; private TrieNode root = new TrieNode(); public void addWord(String word) &#123; TrieNode node = root; for (char c : word.toCharArray()) &#123; if (node.children[c - 'a'] == null) &#123; node.children[c - 'a'] = new TrieNode(); &#125; node = node.children[c - 'a']; &#125; node.item = word; &#125; public boolean search(String word) &#123; return match(word.toCharArray(), 0, root); &#125; private boolean match(char[] chs, int k, TrieNode node) &#123; if (k == chs.length) return !node.item.equals(""); if (chs[k] != '.') &#123; return node.children[chs[k] - 'a'] != null &amp;&amp; match(chs, k + 1, node.children[chs[k] - 'a']); &#125; else &#123; for (int i = 0; i &lt; node.children.length; i++) &#123; if (node.children[i] != null) &#123; if (match(chs, k + 1, node.children[i])) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125;&#125; T&amp;S AnalysisTime: Add: Take at most O(lenOf(word)) time Search: Take O(sizeOf(set)*lenOf(word)) time Space: Take O(numberOf(words) * lenOf(word))]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Backtracking</tag>
        <tag>Design</tag>
        <tag>Tire</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[257 Binary Tree Paths]]></title>
    <url>%2F2017%2F08%2F28%2F257-Binary-Tree-Paths%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return all root-to-leaf paths. For example, given the following binary tree: 1 / \ 2 3 \ 5 All root-to-leaf paths are: ["1-&gt;2-&gt;5", "1-&gt;3"] Solution 1 DFSIt is easy preorder traversal. 1234567891011121314151617181920212223class Solution &#123; public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); if(root == null) return res; fillIn(root, "", res); return res; &#125; private void fillIn(TreeNode root, String s, List&lt;String&gt; res)&#123; if(root == null ) return; if(root.left == null &amp;&amp; root.right == null)&#123; s=s+"-&gt;"+root.val; res.add(s.substring(2, s.length())); return; &#125; s=s+"-&gt;"+root.val; fillIn(root.left, s, res); fillIn(root.right, s, res); &#125;&#125; T&amp;S AnalysisTime: O(NlonN), N times, every time go at most logN deepth. Space: O(logN) for recursion’s depth is logN, and every time it cost constant extra space.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>DFS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[200 Number of Islands]]></title>
    <url>%2F2017%2F08%2F27%2F200-Number-of-Islands%2F</url>
    <content type="text"><![CDATA[Question Given a 2d grid map of ‘1’s (land) and ‘0’s (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water. Example 1: 11110110101100000000 Answer: 1 Example 1: 11000110000010000011 Answer: 3 Solution 1 Union FindUtlize Union Find Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123; public int numIslands(char[][] grid) &#123; int row = grid.length; if(row == 0) return 0; int col = grid[0].length; int count = 0; Point[][] map = new Point[row][col]; // initialize the map, in which the first means its size if negative. for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; map[i][j] = new Point(-1, -1); &#125; &#125; for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if(grid[i][j] == '1')&#123; if(i &gt; 0 &amp;&amp; grid[i-1][j] == '1')&#123; combine(map, i, j, i-1, j); &#125; if(i &lt; row-1 &amp;&amp; grid[i+1][j] == '1')&#123; combine(map, i, j, i+1, j); &#125; if(j &gt; 0 &amp;&amp; grid[i][j-1] == '1')&#123; combine(map, i, j, i, j-1); &#125; if(j &lt; col-1 &amp;&amp; grid[i][j+1] == '1')&#123; combine(map, i, j, i, j+1); &#125; &#125; &#125; &#125; for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if(map[i][j].x&lt; 0 &amp;&amp; grid[i][j] == '1') count++; &#125; &#125; return count; &#125; private void combine(Point[][] map, int x1, int y1, int x2, int y2)&#123; int tx; while(map[x1][y1].x &gt;= 0)&#123; System.out.println(x1+"---"+y1); tx = x1; x1 = map[x1][y1].x; y1 = map[tx][y1].y; &#125; while(map[x2][y2].x &gt;= 0)&#123; tx = x2; x2 = map[x2][y2].x; y2 = map[tx][y2].y; &#125; if(x1==x2 &amp;&amp; y1==y2) return; if(map[x1][y1].x &gt; map[x2][y2].x)&#123; map[x2][y2].x += map[x1][y1].x; map[x1][y1].x = x2; map[x1][y1].y = y2; &#125;else&#123; map[x1][y1].x += map[x2][y2].x; map[x2][y2].x = x1; map[x2][y2].y = y1; &#125; &#125;&#125; T&amp;S AnalysisTime: I sanned the grid and map for constant, so time complexity is O(row*col). Space: O(row*col), since I used the map. Solution 2 DFSOnce meet ‘1, mark it and its connected ‘1’ all to ‘0’, and count + 1. Code12345678910111213141516171819202122232425262728class Solution &#123; public int numIslands(char[][] grid) &#123; int row = grid.length, count = 0; if(row == 0) return 0; int col = grid[0].length; for(int i = 0; i &lt; row; i++)&#123; for(int j = 0; j &lt; col; j++)&#123; if(grid[i][j] == '1')&#123; DFS(grid, i, j); count++; &#125; &#125; &#125; return count; &#125; private void DFS(char[][] grid, int i, int j)&#123; if(i &gt;= grid.length || i&lt; 0 || j &lt; 0 || j &gt;= grid[0].length || grid[i][j] == '0') return; grid[i][j] = '0'; DFS(grid, i-1, j); DFS(grid, i+1, j); DFS(grid, i, j-1); DFS(grid, i, j+1); return; &#125;&#125; T&amp;S AnalysisTime: I sanned the grid and map for constant, so time complexity is O(row*col). Space: O(row*col), for the worst case of recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Union Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15 3Sum]]></title>
    <url>%2F2017%2F08%2F27%2F15-3Sum%2F</url>
    <content type="text"><![CDATA[Question Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero. Note: The solution set must not contain duplicate triplets. For example, given array S = [-1, 0, 1, 2, -1, -4], A solution set is: [ [-1, 0, 1], [-1, -1, 2] ] Solution 1 Two PointersTo make this “three pointers problem” into a two pointers problem, we have to fix one pointer. when it is fixed it turned in to the 2Sum problem. 1234567891011121314151617181920212223242526272829class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); int target, head, tail; Arrays.sort(nums); for(int i = 0; i &lt; nums.length - 2; i++)&#123; if(i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) continue; target = 0-nums[i]; head = i+1; tail = nums.length -1; while(head &lt; tail)&#123; if(nums[head] + nums[tail] == target)&#123; res.add(Arrays.asList(nums[i], nums[head], nums[tail])); head++; tail--; while(head &lt; tail &amp;&amp; nums[head-1] == nums[head]) head++; while(tail &gt; head &amp;&amp; nums[tail+1]==nums[tail]) tail--; &#125;else if(nums[head] + nums[tail] &lt; target) head++; else tail--; &#125; &#125; return res; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[91 Decode Ways]]></title>
    <url>%2F2017%2F08%2F27%2F91-Decode-Ways%2F</url>
    <content type="text"><![CDATA[Question A message containing letters from A-Z is being encoded to numbers using the following mapping: 'A' -&gt; 1 'B' -&gt; 2 ... 'Z' -&gt; 26 Given an encoded message containing digits, determine the total number of ways to decode it. For example, Given encoded message “12”, it could be decoded as “AB” (1 2) or “L” (12). The number of ways decoding “12” is 2. Solution 1 Dynamic ProgrammingThis problem could be done step by step. Code123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numDecodings(String s) &#123; //Special cases and initialization if(s.length() == 0 || s.charAt(0) == '0') return 0; if(s.length() == 1) return 1; int count1 = 1, count2 =1, temp; /* Each step could be adding the former two steps answer, if 2 digits case is larger than 26, than only same as the former one step */ for(int i = 1; i &lt; s.length(); i++)&#123; // 0 should be carefully treated if(s.charAt(i) == '0')&#123; if(s.charAt(i-1)-'0'&gt;2) return 0; else&#123; count1 = count2; count2 = 0; &#125; &#125;else if(s.charAt(i-1)=='1' || (s.charAt(i-1) == '2' &amp;&amp; s.charAt(i)-'0' &lt;= '6'-'0'))&#123; temp = count1; count1 = count1 + count2; count2 = temp; &#125;else&#123; count2 = count1; &#125; &#125; return count1; &#125;&#125; T&amp;S AnalysisTime: Only one scan, thus itis O(n) time. Space: Constant extra space used, space complexity: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Dynamic Programming</tag>
        <tag>Facebook</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[278 First Bad Version]]></title>
    <url>%2F2017%2F08%2F27%2F278-First-Bad-Version%2F</url>
    <content type="text"><![CDATA[Question You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad. Suppose you have n versions [1, 2, …, n] and you want to find out the first bad one, which causes all the following ones to be bad. You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API. Solution 1 Binary SearchCode1234567891011121314151617public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; if(isBadVersion(1)) return 1; int head = 1, tail = n, mid; while(head+1 &lt; tail)&#123; //if use "mid = (head+tail)/2" it will overflow mid = (tail - head)/2 + head; if(isBadVersion(mid)) tail = mid; else head = mid; &#125; return tail; &#125;&#125; T&amp;S AnalysisTime: This question O(log(N)) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Binary Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[17 Letter Combinations of a Phone Number]]></title>
    <url>%2F2017%2F08%2F27%2F17-Letter-Combinations-of-a-Phone-Number%2F</url>
    <content type="text"><![CDATA[Question Given a digit string, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below.Input:Digit string “23”Output: [“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”].Note:Although the above answer is in lexicographical order, your answer could be in any order you want. Solution 1 BacktrackingUse Backtracking method, add an out word letter by letter Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; // Build a Hash Map for the convenience of searching. public List&lt;String&gt; letterCombinations(String digits) &#123; HashMap&lt;Character, String&gt; map = new HashMap&lt;Character, String&gt;()&#123; &#123; put('2', "abc"); put('3', "def"); put('4', "ghi"); put('5', "jkl"); put('6', "mno"); put('7', "pqrs"); put('8', "tuv"); put('9', "wxyz"); &#125; &#125;; List&lt;String&gt; res = new ArrayList&lt;String&gt;(); //Special case if(digits.length() == 0)&#123; return res; &#125; combine(digits, res, 0, "", map); return res; &#125; private void combine(String input, List&lt;String&gt; res, int pos, String word, HashMap&lt;Character, String&gt; map)&#123; //Regard the word length as return condition if(word.length() == input.length())&#123; res.add(word); return; &#125; /* 1. Choose an input number 2. Find its corresponding string 3. Add one letter every time and right after that, go to next turn(next input number) */ for(int i = pos; i &lt; input.length(); i++)&#123; char ch = input.charAt(i); String s = map.get(ch); for(int j =0; j &lt; s.length(); j++) combine(input, res, i+1, word+s.charAt(j), map); &#125; &#125;&#125; T&amp;S AnalysisTime: Each number corresponds to 3 or 4 letters, and time comsuming is multiplied, thus time complexity is O(exp(N)). Space: Space is also multiplied for recursion, thus O(exp(N)).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>Backtracking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[666 Path Sum IV]]></title>
    <url>%2F2017%2F08%2F26%2F666-Path-Sum-IV%2F</url>
    <content type="text"><![CDATA[Question If the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers. For each integer in this list: The hundreds digit represents the depth D of this node, 1 &lt;= D &lt;= 4. The tens digit represents the position P of this node in the level it belongs to, 1 &lt;= P &lt;= 8. The position is the same as that in a full binary tree. The units digit represents the value V of this node, 0 &lt;= V &lt;= 9.Given a list of ascending three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves. Given a list of ascending three-digits integers representing a binary with the depth smaller than 5. You need to return the sum of all paths from the root towards the leaves. Example1: Input: [113, 215, 221] Output: 12 Explanation: The tree that the list represents is: 3 / \ 5 1 The path sum is (3 + 5) + (3 + 1) = 12. Examlpe2: Input: [113, 221] Output: 4 Explanation: The tree that the list represents is: 3 \ 1 The path sum is (3 + 1) = 4. Solution 1 Add dumpy to nullCode:12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; public int pathSum(int[] nums) &#123; int sum = 0, p; List&lt;Integer&gt; compTree = new ArrayList&lt;Integer&gt;(); int level = 0; for(int x: nums) level=Math.max(level, getDigit(x, 3)); for(int i = 1; i &lt;= level; i++)&#123; for(int j = 1; j &lt;= 1&lt;&lt;(i-1); j++)&#123; compTree.add(-1*(i*100+j*10)); &#125; &#125; for(int x : nums)&#123; int index = (1&lt;&lt;(getDigit(x,3)-1))+getDigit(x,2)-2; compTree.set(index, compTree.get(index)*(-1)+getDigit(x, 1)); &#125; for(int i = (1&lt;&lt;(level))-2; i&gt;=0; i--)&#123; p = i; if (compTree.get(p) &lt; 0) continue; if(2*p+1 &lt; (1&lt;&lt;(level))-2 &amp;&amp; (compTree.get(2*p+1) &gt; 0 || compTree.get(2*p+2) &gt; 0)) continue; while(p&gt;=0)&#123; System.out.println(p); sum+=getDigit(compTree.get(p), 1); p=(p+1)/2-1; &#125; &#125; return sum; &#125; private int getDigit(int n, int i)&#123; if(i == 1) return n%10; if(i == 2) return (n/10)%10; if(i == 3) return n/100; return 0; &#125;&#125; T&amp;S AnalysisTime: Only scan constant times, time complexity: O(n) Space: A list is used, space complexity:O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[665 Non-decreasing Array]]></title>
    <url>%2F2017%2F08%2F26%2F665-Non-decreasing-Array%2F</url>
    <content type="text"><![CDATA[Question Given an array with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if array[i] &lt;= array[i + 1] holds for every i (1 &lt;= i &lt; n). Example 1:Input: [4,2,3]Output: TrueExplanation: You could modify the first 4 to 1 to get a non-decreasing array. Example 2:Input: [4,2,1]Output: FalseExplanation: You can’t get a non-decreasing array by modify at most one element. Note:The n belongs to [1, 10,000]. Solution 1 Online SolutionCode:1234567891011121314151617181920class Solution &#123; public boolean checkPossibility(int[] nums) &#123; int i = 0; boolean once = false; for(i = 0; i &lt; nums.length-1; i++)&#123; if(nums[i] &gt; nums[i+1])&#123; if(once) return false; once = true; if(i == 0) continue; if(nums[i+1] &gt;= nums[i-1]) continue; if(i+2 &lt; nums.length &amp;&amp; nums[i] &gt;= nums[i+2]) return false; &#125; &#125; return true; &#125;&#125; T&amp;S AnalysisTime: Only scan once, time complexity: O(n) Space: Constant extra space is used, space complexity:O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[401 Binary Watch]]></title>
    <url>%2F2017%2F08%2F26%2F401-Binary-Watch%2F</url>
    <content type="text"><![CDATA[Question A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).Each LED represents a zero or one, with the least significant bit on the right.For example, the above binary watch reads “3:25”.Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.Example:Input: n = 1Return: [“1:00”, “2:00”, “4:00”, “8:00”, “0:01”, “0:02”, “0:04”, “0:08”, “0:16”, “0:32”]Note:The order of output does not matter.The hour must not contain a leading zero, for example “01:00” is not valid, it should be “1:00”.The minute must be consist of two digits and may contain a leading zero, for example “10:2” is not valid, it should be “10:02”. Solution 1 BacktrackingUse backtracking technology. Regard hour and minute as numbers, find out which numbers could be on the hours an minutes. Build two array representing for each point. Backtracking: Find out number of lights represent for hours and minutes accordingly, for example 6 lights could be from 0-6 to 4-2, we call the pair hour-minute-pair; For each hour-minute-pair, first for hour and then for minutes seprately, each has a initial 0 varible sum: According to array order, add one number to sum, then count minus 1. repet a. until count=0 ,which means we’ve finished one turn selection, put the sum to list, and continue next turn selection. Translate numbers to String Code12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public List&lt;String&gt; readBinaryWatch(int num) &#123; List&lt;String&gt; ans = new ArrayList&lt;String&gt;(); int num1[] = new int[]&#123;8,4,2,1&#125;; int num2[] = new int[]&#123;32,16,8,4,2,1&#125;; for(int i = 0; i &lt;= Math.min(4, num); i++)&#123; List&lt;Integer&gt; l1 = getDigit(num1, i); List&lt;Integer&gt; l2 = getDigit(num2, num-i); for(int h: l1)&#123; if(h &gt;= 12) continue; for(int m: l2)&#123; if(m &gt;= 60) continue; ans.add(h + ":" + ((m &gt;= 10)? "":"0") + m); &#125; &#125; &#125; return ans; &#125; private List&lt;Integer&gt; getDigit( int[] nums, int count)&#123; List&lt;Integer&gt; l = new ArrayList&lt;Integer&gt;(); getDigitHelper(l, nums, count, 0, 0); return l; &#125; private void getDigitHelper(List&lt;Integer&gt; l, int[] nums, int count, int pos, int sum)&#123; if(count == 0)&#123; l.add(sum); return; &#125; for(int i = pos; i &lt; nums.length; i++)&#123; getDigitHelper(l, nums, count-1, i+1, sum+nums[i]); &#125; &#125;&#125; T&amp;S AnalysisTime: This question is all limited, thus time complex is O(1) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backtracking</tag>
        <tag>Bit Manipulate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[67 Add Binary]]></title>
    <url>%2F2017%2F08%2F26%2F67-Add-Binary%2F</url>
    <content type="text"><![CDATA[Question Given two binary strings, return their sum (also a binary string). For example,a = “11”b = “1”Return “100”. Solution 1 From tail to headCode1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Solution &#123; public String addBinary(String a, String b) &#123; String res = "", tempS; int i = a.length()-1, j = b.length()-1; int carry = 0, temp; while(i &gt;=0 &amp;&amp; j&gt;=0)&#123; temp = a.charAt(i)-'0'+b.charAt(j)-'0'+carry; switch(temp)&#123; case 0: res = "0" + res; break; case 1: res = "1" + res; carry =0; break; case 2: res = "0" + res; carry =1; break; case 3: res = "1" + res; break; &#125; j--; i--; &#125; if(i == -1) tempS = b.substring(0, j+1); else tempS = a.substring(0, i+1); int k = tempS.length()-1; while(k&gt;=0 &amp;&amp; carry==1)&#123; if(tempS.charAt(k) == '1') res = "0"+res; else&#123; res = "1" +res; carry =0; &#125; k--; &#125; if(carry ==0 ) return tempS.substring(0, k+1)+res; else return "1" + res; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Facebook</tag>
        <tag>String</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20 Valid Parentheses]]></title>
    <url>%2F2017%2F08%2F26%2F20-Valid-Parentheses%2F</url>
    <content type="text"><![CDATA[Question Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. Solution 1 Use StackUse Stack to store left symbol accordingly, if the comming right symbol does not match the top, return false. If left-right count doesn’t match, stack will be empty when right comming or still not empty after the string is all checked Code12345678910111213141516171819202122232425class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); HashMap&lt;Character, Character&gt; map = new HashMap&lt;Character, Character&gt;(); map.put(')','('); map.put(']','['); map.put('&#125;','&#123;'); for(int i = 0; i &lt; s.length(); i++)&#123; if(s.charAt(i) == '(' || s.charAt(i)== '[' || s.charAt(i)=='&#123;')&#123; stack.push(s.charAt(i)); &#125;else&#123; if(stack.size()==0) return false; if(stack.pop() != map.get(s.charAt(i))) return false; &#125; &#125; if(stack.size() &gt; 0) return false; return true; &#125;&#125; T&amp;S AnalysisTime: Only scan once, so it’s O(n). Space: Also, O(n) for using the stack.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[283 Move Zeros]]></title>
    <url>%2F2017%2F08%2F26%2F283-Move-Zeros%2F</url>
    <content type="text"><![CDATA[Question Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0] Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Solution 1 Two PointersOne for first zero position, one for curser. Code1234567891011121314151617181920212223242526class Solution &#123; public void moveZeroes(int[] nums) &#123; int zeroH = -1, cur = 0; for(cur =0; cur &lt; nums.length; cur++)&#123; if(nums[cur] == 0)&#123; if(zeroH == -1) zeroH = cur; &#125;else&#123; if(zeroH &gt;= 0)&#123; swap(nums, zeroH, cur); if(zeroH &lt; nums.length-1 &amp;&amp; nums[zeroH+1] == 0) zeroH++; else zeroH = cur; &#125; &#125; &#125; &#125; private void swap(int[] nums, int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; T&amp;S AnalysisTime: Only scan once, so it’s O(n). But in this problem, swap operation’s count is important. The operation is O(nonzeros) in worst case. Space: O(1)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Facebook</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[617 Merge Two Binary Trees]]></title>
    <url>%2F2017%2F08%2F25%2F617-Merge-Two-Binary-Trees%2F</url>
    <content type="text"><![CDATA[Question Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 Output: Merged tree: 3 / \ 4 5 / \ \ 5 4 7 Note: The merging process must start from the root nodes of both trees. Solution 1 Recursive BuildingFirst, it is easy to know how to merge two small trees, so divide the question into small pieces. Everytime, merge one node and then, merge its two children. Note: To makeup unexisting nodes, in order to follow the recirsion pattern, we set null still be null in the next recursion. Code123456789101112class Solution &#123; public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123; TreeNode t; if(t1 == null &amp;&amp; t2 ==null) return null; t = new TreeNode((t1 == null?0:t1.val)+(t2 == null? 0: t2.val)); t.left = mergeTrees(t1==null?null:t1.left,t2==null?null:t2.left); t.right = mergeTrees(t1==null?null:t1.right,t2==null?null:t2.right); return t; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[606 Construct String from Binary Tree]]></title>
    <url>%2F2017%2F08%2F25%2F606-Construct-String-from-Binary-Tree%2F</url>
    <content type="text"><![CDATA[Question You need to construct a string consists of parenthesis and integers from a binary tree with the preorder traversing way. The null node needs to be represented by empty parenthesis pair “()”. And you need to omit all the empty parenthesis pairs that don’t affect the one-to-one mapping relationship between the string and the original binary tree. Example 1: Input: Binary tree: [1,2,3,4] 1 / \ 2 3 / 4 Output: "1(2(4))(3)" Explanation: Originallay it needs to be "1(2(4)())(3()())", but you need to omit all the unnecessary empty parenthesis pairs. And it will be "1(2(4))(3)". Example2: Input: Binary tree: [1,2,3,null,4] 1 / \ 2 3 \ 4 Output: "1(2()(4))(3)" Explanation: Almost the same as the first example, except we can't omit the first parenthesis pair to break the one-to-one mapping relationship between the input and the output. Solution 1 Recursive SolutionEasy to understand. Code123456789101112131415161718192021class Solution &#123; public String tree2str(TreeNode t) &#123; String s=""; return T2S(t); &#125; private String T2S(TreeNode t)&#123; if(t == null) return ""; if(t.left == null &amp;&amp; t.right == null) return t.val+""; if(t.left == null) return t.val +"()"+"("+ T2S(t.right) +")"; else if(t.right == null) return t.val + "("+ T2S(t.left) +")"; else return t.val + "("+ T2S(t.left) +")"+"("+ T2S(t.right) +")"; &#125;&#125; T&amp;S AnalysisTime: O(n) Space: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>String</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[572 Subtree of Another Tree]]></title>
    <url>%2F2017%2F08%2F25%2F572-Subtree-of-Another-Tree%2F</url>
    <content type="text"><![CDATA[Question Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node’s descendants. The tree s could also be considered as a subtree of itself. Example 1: Given tree s: 3 / \ 4 5 / \ 1 2 Given tree t: 4 / \ 1 2 Return true, because t has the same structure and node values with a subtree of s. Example2:Given tree s: 3 / \ 4 5 / \ 1 2 / 0 Given tree t: 4 / \ 1 2 Return false. Solution 1 Recursive Find and Recursive CompareSince this problem is signed as Easy, I did not think much and use normal solutions. 1234567891011121314151617181920212223242526272829class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; List&lt;TreeNode&gt; store = new ArrayList&lt;TreeNode&gt;(); findSameRoot(s, t.val, store); for(TreeNode x: store)&#123; if(sameTree(x, t)) return true; &#125; return false; &#125; private boolean sameTree(TreeNode x, TreeNode t)&#123; if(x == null &amp;&amp; t == null) return true; if((x == null &amp;&amp; t !=null) || (x != null &amp;&amp; t == null)) return false; return (x.val == t.val) &amp;&amp; (sameTree(x.left, t.left)) &amp;&amp; (sameTree(x.right, t.right)); &#125; private void findSameRoot(TreeNode s, int v, List&lt;TreeNode&gt; store)&#123; if(s == null) return; if(s.val == v) store.add(s); findSameRoot(s.left, v, store); findSameRoot(s.right, v, store); &#125;&#125; T&amp;S AnalysisTime: Time complexity is large, it is O( n(s)*n(t) ) in the worst case, but I think in most case, there is not much same root, maybe one or two, so generally it is O(n(s)+n(t)). Space: Recursion is used, thus as calculated it should be O(n(s)). Solution 2 MorrisInorderThis is a beautiful solution to test morrisInorder. Code12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isSubtree(TreeNode s, TreeNode t) &#123; return morrisInorder(s).contains(morrisInorder(t)); &#125; private String morrisInorder(TreeNode t)&#123; String str = ""; TreeNode cur = t, temp; while(cur != null)&#123; if(cur.left == null)&#123; str+="l"; str+=cur.val; cur = cur.right; if(cur == null)&#123; System.out.println(str+"r"); return str+"r"; &#125; &#125;else&#123; temp=cur.left; while(temp.right != null &amp;&amp; temp.right !=cur) temp = temp.right; if(temp.right == null)&#123; temp.right = cur; cur = cur.left; &#125;else&#123; str+="r"; str+=cur.val; temp.right = null; cur = cur.right; &#125; &#125; &#125; System.out.println(str+"r"); return str+"r"; &#125;&#125; T&amp;S AnalysisTime: O(n)Space: O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[513 Find Bottom Left Tree Value]]></title>
    <url>%2F2017%2F08%2F25%2F513-Find-Bottom-Left-Tree-Value%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, find the leftmost value in the last row of the tree. Example1: Input: 1 / \ 2 3 / / \ 4 5 6 / 7 Output: 7 Note: You may assume the tree (i.e., the given root node) is not NULL. Solution 1 BFS-LevelorderCode123456789101112131415161718192021222324class Solution &#123; public int findBottomLeftValue(TreeNode root) &#123; List&lt;TreeNode&gt; q = new ArrayList&lt;TreeNode&gt;(); List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); TreeNode p; int len; q.add(root); while(q.size()&gt;0)&#123; len = q.size(); for(int i = 0; i &lt; len; i++)&#123; p = q.remove(0); if(p.left != null) q.add(p.left); if(p.right != null) q.add(p.right); temp.add(p.val); &#125; if(q.size()&gt;0) temp.clear(); &#125; return temp.get(0); &#125;&#125; T&amp;S AnalysisTime: Every node is visited once, so the time complexity is O(n). Space: One Stack is used to store at most half of the elements, thus, the space complexity is also O(n). Solution 2 DFS Solution-PreorderThis method does not requires stack or queue, first go as left as it can, record its maxLevel. Than go right step by step, once the level is more than maxLevel turn the res to that value. Code12345678910111213141516171819202122public class Solution &#123; private int maxLevel = -1; private int res = 0; public int findBottomLeftValue(TreeNode root) &#123; dfs(root, 0); return res; &#125; private void dfs(TreeNode root, int level) &#123; if(root == null) return; dfs(root.left, level+1); if(level &gt; maxLevel)&#123; maxLevel = level; res = root.val; &#125; dfs(root.right, level+1); &#125;&#125; T&amp;S AnalysisTime: Every node is visited once, so the time complexity is O(n). Space: Though it does not use apparent extra data structure, it uses recursions in the dfs function, thus its space complexity is also O(n)]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>BFS</tag>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[563 Binary Tree Tilt]]></title>
    <url>%2F2017%2F08%2F25%2F563-Binary-Tree-Tilt%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return the tilt of the whole tree. The tilt of a tree node is defined as the absolute difference between the sum of all left subtree node values and the sum of all right subtree node values. Null node has tilt 0. The tilt of the whole tree is defined as the sum of all nodes’ tilt. Example: Input: 1 / \ 2 3 Output: 1 Explanation: Tilt of node 2 : 0 Tilt of node 3 : 0 Tilt of node 1 : |2-3| = 1 Tilt of binary tree : 0 + 0 + 1 = 1 Note: The sum of node values in any subtree won’t exceed the range of 32-bit integer. All the tilt values won’t exceed the range of 32-bit integer. Solution 1 Brute Force – Recusion in RecusionIt is the easiest way for a coder to come up with a recusion solution, but I have to addmit that it is hard for the computer. So, mostly, I’d rather think much longer to come up with a iterative way. This time, however, I can’t find one, and even put a recusion into a recusion. Though the solution is accepted, I am still not satisfied. Code:123456789101112131415161718192021class Solution &#123; public int findTilt(TreeNode root) &#123; return getTilt(root); &#125; private int getTilt(TreeNode t)&#123; int sum = 0; if(t == null) return 0; sum += Math.abs(getSum(t.left)-getSum(t.right)); return sum + getTilt(t.left) + getTilt(t.right); &#125; private int getSum(TreeNode t)&#123; int sum = 0; if(t == null) return 0; return sum + getSum(t.left)+getSum(t.right)+t.val; &#125;&#125; T&amp;S AnalysisTime: As I calculated, the getSum() function has time complexity of O(n), and getTilt()‘s is O(nlogn). Space: As calculated, both functions’ space complexities are O(n). Solution 2 Use Global VaribleAs I see the leetcode’s official solution, there is only a method with a class-global varible, I thought it was not allowed. Code:1234567891011121314151617public class Solution &#123; int tilt=0; public int findTilt(TreeNode root) &#123; traverse(root); return tilt; &#125; public int traverse(TreeNode root) &#123; if(root==null ) return 0; int left=traverse(root.left); int right=traverse(root.right); tilt+=Math.abs(left-right); return left+right+root.val; &#125;&#125; T&amp;S AnalysisTime: In this case, the time complexity is O(n). Space: As calculated the space complexity is also O(n).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2017%2F08%2F24%2F144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return the preorder traversal of its nodes’ values. For example: Given binary tree {1, #, 2, 3}, 1 \ 2 / 3 Note: Recursive solution is trivial, could you do it iteratively? Solution 1 Morris Order TraverseAs I see this problem, I thought I need a Stack or Queue or something like that. But I was wrong. After I knew this solution, I was so surprised that I decided to consider this method of traversing every time I meet Tree problem. Let me explain, to make inorder with using only constant space and linear time, we need only follow these principles: When left child is null, visit the current node and set current node as itd right child. Other wise, find the pre-node of current node: if the pre-node‘s right child is null, then visit current node set its right child as current node and set current child as its left child otherwise, the pre-node‘s right child must be current node, and set pre-node‘s _right child as null to reset the original tree. Then set current node as its right child. Q: How to find ones pre-node? A: In its left subtree, find the mose right node. Code123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); morrisOrder(ans, root); return ans; &#125; private void morrisOrder(List&lt;Integer&gt; li, TreeNode t)&#123; TreeNode p; while(t != null)&#123; if(t.left == null)&#123; li.add(t.val); t=t.right; &#125;else&#123; p = t.left; while(p.right != t &amp;&amp; p.right != null) p = p.right; if(p.right == null)&#123; p.right = t; li.add(t.val); t = t.left; &#125;else&#123; p.right = null; t = t.right; &#125; &#125; &#125; &#125;&#125; T&amp;S AnalysisTime: As analysed, every node would be visted at most twice, thus time complexity is O(n); Space: This is where it’s excellent, we did not use any other space that is proportion to node numbers, nor do we used recursion, thus extra space complexity is O(1);]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Morris Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2017%2F08%2F24%2F94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return the inorder traversal of its nodes’ values. For example: Given binary tree [1,null,2,3], Note: Recursive solution is trivial, could you do it iteratively? Solution 1 Morris Order TraverseAs I see this problem, I thought I need a Stack or Queue or something like that. But I was wrong. After I knew this solution, I was so surprised that I decided to consider this method of traversing every time I meet Tree problem. Let me explain, to make inorder with using only constant space and linear time, we need only follow these principles: When left child is null, visit the current node and set current node as itd right child. Other wise, find the pre-node of current node: if the pre-node‘s right child is null, then set its right child as current node and set current child as its left child otherwise, the pre-node‘s right child must be current node, visit current node and set pre-node‘s _right child as null to reset the original tree. Then set current node as its right child. Q: How to find ones pre-node? A: In its left subtree, find the mose right node. Code123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); morrisOrder(ans, root); return ans; &#125; private void morrisOrder(List&lt;Integer&gt; li, TreeNode t)&#123; TreeNode p; while(t != null)&#123; if(t.left == null)&#123; li.add(t.val); t=t.right; &#125;else&#123; p = t.left; while(p.right != t &amp;&amp; p.right != null) p = p.right; if(p.right == null)&#123; p.right = t; t = t.left; &#125;else&#123; p.right = null; li.add(t.val); t = t.right; &#125; &#125; &#125; &#125;&#125; T&amp;S AnalysisTime: As analysed, every node would be visted at most twice, thus time complexity is O(n); Space: This is where it’s excellent, we did not use any other space that is proportion to node numbers, nor do we used recursion, thus extra space complexity is O(1);]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Morris Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[455 Add Two Numbers II]]></title>
    <url>%2F2017%2F08%2F24%2F455-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[Question You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 Solution 1 Use StackUse Stack to save time, but lose space. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int len1 = 0, len2 = 0; ListNode dumpy = new ListNode(0); ListNode cur1 = l1, cur2 = l2, cur = dumpy; int c = 0; Stack&lt;ListNode&gt; s = new Stack&lt;ListNode&gt;(); while(cur1 != null)&#123; len1++; cur1 = cur1.next; &#125; while(cur2 != null)&#123; len2++; cur2 = cur2.next; &#125; cur1 = l1; cur2 = l2; s.push(dumpy); if(len1 &gt;= len2)&#123; for(int i =0; i&lt; len1-len2; i++)&#123; cur.next = new ListNode(cur1.val); cur1 = cur1.next; cur = cur.next; s.push(cur); &#125; &#125;else&#123; for(int i =0; i&lt; len2-len1; i++)&#123; cur.next = new ListNode(cur2.val); cur2 = cur2.next; cur = cur.next; s.push(cur); &#125; &#125; while(cur1 != null)&#123; cur.next = new ListNode(cur1.val + cur2.val); s.push(cur.next); cur1 = cur1.next; cur2 = cur2.next; cur = cur.next; &#125; while(s.size()&gt;0)&#123; if(s.peek().val+c&gt;=10)&#123; s.pop().val+=c-10; c=1; &#125;else&#123; s.pop().val+=c; c=0; &#125; &#125; if(dumpy.val == 0) return dumpy.next; return dumpy; &#125; &#125; T&amp;S AnalysisTime: I sanned the list and Stack for constant, so time complexity is O(n). Space: Obviously, O(n), since I used the Stack.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328 Odd Even Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F328-Odd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … Solution 1 Pointers TrackingI use three pointers to track the list, and add to the tail according. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return null; ListNode headOdd = new ListNode(0), headEven = new ListNode(0), curOdd = headOdd, curEven = headEven, cur=new ListNode(0), dumpy = cur; cur.next = head; boolean isOdd = false; while(cur != null)&#123; isOdd = !isOdd; cur = cur.next; if(isOdd)&#123; curOdd.next = cur; curOdd = curOdd.next; &#125;else&#123; curEven.next = cur; curEven = curEven.next; &#125; &#125; cur = dumpy; curEven = headEven.next; curOdd = headOdd.next; while(curOdd != null)&#123; cur.next = curOdd; cur = cur.next; curOdd = curOdd.next; &#125; while(curEven != null)&#123; cur.next = curEven; cur = cur.next; curEven = curEven.next; &#125; return dumpy.next; &#125; &#125; T&amp;S AnalysisTime: I sanned the list for constant, so time complexity is O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[237 Delete Node in a Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Solution 1 Easy SolutionCode1234567class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(1). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[234 Palindrome Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list, determine if it is a palindrome. Solution 1 Reverse HalfI reversed the latter half, and compare. Code1234567891011121314151617181920212223242526272829class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode fast = head, slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; slow=reverseList(slow); fast = head; while(slow != null &amp;&amp; fast !=null)&#123; if(slow.val != fast.val) return false; slow = slow.next; fast =fast.next; &#125; return true; &#125; private ListNode reverseList(ListNode p)&#123; ListNode last = null, cur = p, temp; while(cur != null)&#123; temp = cur.next; cur.next = last; last = cur; cur = temp; &#125; return last; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206 Reverse Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Reverse a singly linked list. Solution 1 Easy solutionToo easy to explain. Code12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode cur = head, last=null, temp; while(cur != null)&#123; temp = cur.next; cur.next = last; last = cur; cur = temp; &#125; return last; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203 Removed Linked List Elements]]></title>
    <url>%2F2017%2F08%2F24%2F203-Removed-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[Question Remove all elements from a linked list of integers that have value val. Example Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6 Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 Solution 1 Easy Problem, Easy SolutionNo explanation. Code:123456789101112131415161718class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode p = dumpy; ListNode q; while(p != null &amp;&amp; p.next != null)&#123; q = p; while(p.next!=null &amp;&amp; p.next.val == val) p=p.next; q.next=p.next; p=p.next; &#125; return dumpy.next; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160 Intersection of Two Linked Lists]]></title>
    <url>%2F2017%2F08%2F24%2F160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[Question Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. Your code should preferably run in O(n) time and use only O(1) memory. Solution 1 Fast and Slow PointersSince we could change the structure in the process, we can make it a circle and usc fast and slow pointers to solve the problem. Code123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode fast = headB, slow = headB, p = headA; if(headA == null || headB == null) return null; while(p.next != null) p=p.next; p.next = headA; slow = slow.next; if(slow == null)&#123; p.next = null; return null; &#125; fast = slow.next; while(fast != null &amp;&amp; fast.next != null &amp;&amp; fast != slow)&#123; fast = fast.next.next; slow = slow.next; &#125; if(fast == null || fast.next == null)&#123; p.next =null; return null; &#125; slow =headB; while(fast != slow)&#123; fast = fast.next; slow =slow.next; &#125; p.next = null; return fast; &#125;&#125; T&amp;S AnalysisTime: It only envolve sanning the circle constant times, thus time complexity is O(n). Space: Constant extra Space is used, thus, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Two Pointers</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148 Sort List]]></title>
    <url>%2F2017%2F08%2F24%2F148-Sort-List%2F</url>
    <content type="text"><![CDATA[Question Sort a linked list in O(n log n) time using constant space complexity. Solution 1 Bottom to TopSince we could only use O(1) extra space, recursive method will not be acceptable. Thus, there is a Bottom-to-Top solution. Its idea is same as merge sort, just it’s not recursive, it is not easy to explain in detail, but the code is below. We need to be careful of boundary problems. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public ListNode sortList(ListNode head) &#123; int length = 0; ListNode left, right, tail, cur; ListNode dumy = new ListNode(0); dumy.next = head; cur = dumy.next; while(cur != null)&#123; length++; cur = cur.next; &#125; for(int step = 1; step &lt; length; step&lt;&lt;=1)&#123; cur = dumy.next; tail = dumy; while(cur != null)&#123; left = cur; right = seperate(left, step); cur = seperate(right, step); tail = merge(left, right, tail); &#125; &#125; return dumy.next; &#125; // seperate the list from the "step" point private ListNode seperate(ListNode head, int step)&#123; ListNode p; for(int i = 1; head != null &amp;&amp; i &lt; step; i++) head = head.next; if(head == null) return null; p = head.next; head.next = null; return p; &#125; // merge two list, add to the "head" and return its tail private ListNode merge(ListNode l1, ListNode l2, ListNode head)&#123; ListNode p = head; while( l1 != null &amp;&amp; l2 != null )&#123; if(l1.val &lt;= l2.val)&#123; p.next = l1; l1 = l1.next; &#125;else&#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if(l1 == null)&#123; p.next = l2; while(l2.next != null) l2 = l2.next; return l2; &#125; else&#123; p.next = l1; while(l1.next != null) l1 = l1.next; return l1; &#125; &#125; T&amp;S AnalysisTime: Obviously, as the problem required, it’s O(nlogn). Space: It’s O(1) for not using recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143 Reorder List]]></title>
    <url>%2F2017%2F08%2F24%2F143-Reorder-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list L: L0?L1?…?Ln-1?Ln, reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?… You must do this in-place without altering the nodes’ values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. Solution 1 Seperate, Reverse and MergeThis solution might seem complicated, but it is in fact fast and require only constant extra space. First, SEPERATE the list into two parts at its middle point. If its length is odd, then the former one should be longer. Second, REVERSE the latter part using the function reverseList. Finally, MERGE the two lists again, and we fot the correct answer. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if(head == null || head.next == null) return; int l = 0, i; ListNode p = head, temp1, temp2, q=p, t; while(p!=null)&#123; l += 1; p = p.next; &#125; p=head; for(i = 0; i &lt; (l-1)/2; i++) q=q.next; t=q; q.next=reverseList(q.next); q=q.next; t.next=null; for(i = 0; i &lt;= (l-1)/2; i++)&#123; if(q == null) return; temp1 = p.next; p.next = q; temp2 = q.next; q.next =temp1; p = temp1; q = temp2; &#125; &#125; public ListNode reverseList( ListNode p)&#123; ListNode head; head = p; ListNode temp = null, q; while(p != null)&#123; head = p; q = p.next; p.next = temp; temp = p; p=q; &#125; return head; &#125;&#125; T&amp;S AnalysisTime: As I said, it is fast enough, since it is only evolved with some scanning operation, thus the time complexity is O(n). Space: Space Complexity is obviously O(1), since only constant extra space is used.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138 Copy List with Random Pointer]]></title>
    <url>%2F2017%2F08%2F23%2F138-Copy-List-with-Random-Pointer%2F</url>
    <content type="text"><![CDATA[QuestionA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Solution 1 Hasp-MapWe have to copy the whole list and random pointers, thus we first copy the next line, meanwhile, push the original : new to haspmap, for convenience of copying the random line. Code12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;(); RandomListNode res = new RandomListNode(0); RandomListNode p = res; RandomListNode q = head; while(q != null)&#123; p.next = new RandomListNode(q.label); map.put(q, p.next); q=q.next; p=p.next; &#125; map.put(null, null); p=res.next; q=head; while(q != null)&#123; p.random=map.get(q.random); p=p.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Hashing inserting and querying operation is so fast that it could be considered as O(1), in this case, since we scanned the linked list two times, time complexity should be O(n). Space: Considering extra space, it is obvious O(n), to build the hash map. Solution 2 Without HashThis method is not accepted, because it has to change the original linked list’s next attribution, but it only cost O(1) Space! Code1234567891011121314151617181920212223242526272829public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; RandomListNode p = head; RandomListNode res = new RandomListNode(0); RandomListNode q = res; RandomListNode temp; while(p != null)&#123; q.next = new RandomListNode(p.label); q.next.random = p.random; temp = p; p=p.next; temp.next = q.next; q=q.next; &#125; q = res.next; while(q != null)&#123; if(q.random != null) q.random = q.random.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Same as above, O(n). Space:Only Constant extra space used, so it’s O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[661 Image Smoother]]></title>
    <url>%2F2017%2F08%2F23%2F661-Image-Smoother%2F</url>
    <content type="text"><![CDATA[Question Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. example: Input:[[1,1,1], [1,0,1], [1,1,1]] Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Solution 1 Temp Array to Save SpaceAs I see the problem, I know that time complexity will not be less than O(row * col). Thus, I try to find a way to save space, which shold have been O(row * col), too. In this solution, I used two temp arraies, temp1 and temp2, see the code below. Code class Solution { public int[][] imageSmoother(int[][] M) { int row = M.length, col = M[0].length; int[] temp1 = new int[row]; int[] temp2 = new int[row]; for(int i = 0; i &lt; row; i++){ temp1[i] = findAve(M, i, 0); } for(int j = 1; j &lt; col; j++){ for(int i = 0; i &lt; row; i++) temp2[i] = findAve(M, i, j); for(int i = 0; i &lt; row; i++){ M[i][j-1]=temp1[i]; temp1[i] = temp2[i]; } } for( int i = 0; i &lt; row; i++) M[i][col-1] = temp1[i]; return M; } public int findAve(int [][] M, int i, int j){ int sum = 0, num = 9; for(int a = i-1; a &lt;= i+1; a++){ for(int b = j-1; b&lt;=j+1; b++){ if((a&lt;0 || a&gt; M.length-1) || (b&lt;0 || b&gt;M[0].length-1)){ num--; }else{ sum+=M[a][b]; } } } return sum/num; } } T&amp;S AnalysisTime: The time complexity should not be lesser, it’s O(row * col). Space: Only constant extra space is used, except the two temp array, thus space complexity is O(row), whic could be turned to O(min(row, col)) by choosing the fewer one, but the code will be much longer.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Space Saving</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[643 Maxium Average Subarray I]]></title>
    <url>%2F2017%2F08%2F23%2F643-Maxium-Average-Subarray-I%2F</url>
    <content type="text"><![CDATA[Question Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. example: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Solution 1 Cumulative ArraySince it’s a contiguous array comparasion, we can first find the sum array, then deduce accordingly to easily find those sums. Code1234567891011121314class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; for(int i = 1; i &lt; nums.length; i++ )&#123; nums[i]+=nums[i-1]; &#125; int max = nums[k-1]; for(int i = 0; i &lt; nums.length-k; i++)&#123; if(nums[i+k] - nums[i] &gt; max) max = nums[i+k] - nums[i]; &#125; return (double)max/k; &#125;&#125; T&amp;S AnalysisTime: Only O(n) because we scanned the array two times. Space: O(1), if we use the orginal array to store the cumulative array.Otherwise, it should be O(n). Solution 2 Window ScanIf we know one continous sum, we can easily find out the next by adding the next number and deducting the head number. Code123456789101112131415161718class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; int maxS = 0; for(int i=0; i &lt; k; i++)&#123; maxS+=nums[i]; &#125; int current = maxS; int head = 0, tail = k-1; while(tail &lt; nums.length-1)&#123; current = current+nums[tail+1]-nums[head]; maxS = Math.max(maxS, current); head++; tail++; &#125; return (double)maxS/k; &#125;&#125; T&amp;S AnalysisTime: Since only scan once, the time complexity is o(n). Space: Constant extra space is used, thus space complexity is O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[628 Maximum Product of Three Numbers]]></title>
    <url>%2F2017%2F08%2F22%2F628-Maximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[Question Given an integer array, find three numbers whose product is maximum and output the maximum product. Example: Input: [1,2,3]Output: 6 Solution 1 SortThere are only 3 possible largest comnination, 2 smallest negative + 1 largest positive, or 3 largest positive, or 3 smallest negative. Thus, sorting first, then it is a very straightforward problem. Code12345678910class Solution &#123; public int maximumProduct(int[] nums) &#123; Arrays.sort(nums); int l = nums.length; int a = nums[0], b = nums[1], c= nums[2], d = nums[l-1], e = nums[l-2], f = nums[l-3]; return Math.max(a*b*c, Math.max(a*b*d, d*e*f)); &#125;&#125; T&amp;S AnalysisTime: Since there is only one sort operation and some constant time operations, its time complexity is O(nlogn), where n represents the length of the array. Space: Space complexity is obviously O(nlogn), since only sorting cost extra space. P.S.Since we only have to find those 5 numbers, we can at most scan the array one time to get them, in this way, we get an O(n) time and O(1) Extra Space solution.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[621 Task Scheduler]]></title>
    <url>%2F2017%2F08%2F22%2F621-Task-Scheduler%2F</url>
    <content type="text"><![CDATA[Question Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. example: Input : tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2 Output : 8 Explanation : A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Solution 1 Max-HeapSince what a charcter is does not affect the result, we only have to ocnsider their counts. Following is an intutional solution, we arrange the largest first, which is to be verify. But it works. So we need a max-heap – a fast way to find the largest. Step 1Store the number of each charaters in a Max-Heap Step 2Loop. One loop contains n steps, each step remove one current largest, if it is still not totally removed, add it to a temp ArrayList. If the queue is empty before n steps, then addidle time interval accordingly. Afterwards, put all elements in the temp array to the queue again. Code:12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if(n==0) return tasks.length; int[] map = new int[26]; int time = 0, i=0; PriorityQueue &lt; Integer &gt; queue = new PriorityQueue &lt; Integer &gt; (26, Collections.reverseOrder()); int intervals=0; for(char c : tasks) map[(int)(c-'A')]++; for(int x : map)&#123; if(x &gt; 0) queue.add(x); &#125; while(queue.size()&gt;0)&#123; i=0; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); while(i &lt;= n)&#123; if(queue.peek()&gt;1) temp.add(queue.poll()-1); else queue.poll(); time++; i++; if(queue.size()==0)&#123; if(temp.size()!=0)&#123; time+=n-i+1; break; &#125; else&#123; return time; &#125; &#125; &#125; for(int x: temp) queue.add(x); &#125; return time; &#125;&#125; T&amp;S AnalysisTime: Since the size of queue is limited under 26, time complexity only depend on n linearly, thus, time complexity is O(n). Space: Space complexity is obviously O(1), because there are at most 26 kinds of characters. Solution 2 Counting Idle TimeThis method first count the minium idle time, then calculate out the result. Code12345678910111213public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - 'A']++; Arrays.sort(map); int max_val = map[25] - 1, idle_slots = max_val * n; for (int i = 24; i &gt;= 0 &amp;&amp; map[i] &gt; 0; i--) &#123; idle_slots -= Math.min(map[i], max_val); &#125; return idle_slots &gt; 0 ? idle_slots + tasks.length : tasks.length; &#125;&#125; T&amp;S AnalysisTime: O(n). It is obvious. Spaece: O(1). Also obvious.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Greedy</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog Starts Here]]></title>
    <url>%2F2017%2F08%2F22%2FNew-Article%2F</url>
    <content type="text"><![CDATA[Hi, this is a blog about coding, recoding my learning journey from 2017 summer.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>general</tag>
      </tags>
  </entry>
</search>
