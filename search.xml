<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[144 Binary Tree Preorder Traversal]]></title>
    <url>%2F2017%2F08%2F24%2F144-Binary-Tree-Preorder-Traversal%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return the preorder traversal of its nodes’ values. For example: Given binary tree {1, #, 2, 3}, 1 \ 2 / 3 Note: Recursive solution is trivial, could you do it iteratively? Solution 1 Morris Order TraverseAs I see this problem, I thought I need a Stack or Queue or something like that. But I was wrong. After I knew this solution, I was so surprised that I decided to consider this method of traversing every time I meet Tree problem. Let me explain, to make inorder with using only constant space and linear time, we need only follow these principles: When left child is null, visit the current node and set current node as itd right child. Other wise, find the pre-node of current node: if the pre-node‘s right child is null, then visit current node set its right child as current node and set current child as its left child otherwise, the pre-node‘s right child must be current node, and set pre-node‘s _right child as null to reset the original tree. Then set current node as its right child. Q: How to find ones pre-node? A: In its left subtree, find the mose right node. Code123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); morrisOrder(ans, root); return ans; &#125; private void morrisOrder(List&lt;Integer&gt; li, TreeNode t)&#123; TreeNode p; while(t != null)&#123; if(t.left == null)&#123; li.add(t.val); t=t.right; &#125;else&#123; p = t.left; while(p.right != t &amp;&amp; p.right != null) p = p.right; if(p.right == null)&#123; p.right = t; li.add(t.val); t = t.left; &#125;else&#123; p.right = null; t = t.right; &#125; &#125; &#125; &#125;&#125; T&amp;S AnalysisTime: As analysed, every node would be visted at most twice, thus time complexity is O(n); Space: This is where it’s excellent, we did not use any other space that is proportion to node numbers, nor do we used recursion, thus extra space complexity is O(1);]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Morris Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[94 Binary Tree Inorder Traversal]]></title>
    <url>%2F2017%2F08%2F24%2F94-Binary-Tree-Inorder-Traversal%2F</url>
    <content type="text"><![CDATA[Question Given a binary tree, return the inorder traversal of its nodes’ values. For example: Given binary tree [1,null,2,3], Note: Recursive solution is trivial, could you do it iteratively? Solution 1 Morris Order TraverseAs I see this problem, I thought I need a Stack or Queue or something like that. But I was wrong. After I knew this solution, I was so surprised that I decided to consider this method of traversing every time I meet Tree problem. Let me explain, to make inorder with using only constant space and linear time, we need only follow these principles: When left child is null, visit the current node and set current node as itd right child. Other wise, find the pre-node of current node: if the pre-node‘s right child is null, then set its right child as current node and set current child as its left child otherwise, the pre-node‘s right child must be current node, visit current node and set pre-node‘s _right child as null to reset the original tree. Then set current node as its right child. Q: How to find ones pre-node? A: In its left subtree, find the mose right node. Code123456789101112131415161718192021222324252627282930class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;(); morrisOrder(ans, root); return ans; &#125; private void morrisOrder(List&lt;Integer&gt; li, TreeNode t)&#123; TreeNode p; while(t != null)&#123; if(t.left == null)&#123; li.add(t.val); t=t.right; &#125;else&#123; p = t.left; while(p.right != t &amp;&amp; p.right != null) p = p.right; if(p.right == null)&#123; p.right = t; t = t.left; &#125;else&#123; p.right = null; li.add(t.val); t = t.right; &#125; &#125; &#125; &#125;&#125; T&amp;S AnalysisTime: As analysed, every node would be visted at most twice, thus time complexity is O(n); Space: This is where it’s excellent, we did not use any other space that is proportion to node numbers, nor do we used recursion, thus extra space complexity is O(1);]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Tree</tag>
        <tag>Morris Order</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[455 Add Two Numbers II]]></title>
    <url>%2F2017%2F08%2F24%2F455-Add-Two-Numbers-II%2F</url>
    <content type="text"><![CDATA[Question You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Follow up: What if you cannot modify the input lists? In other words, reversing the lists is not allowed. Example: Input: (7 -&gt; 2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 8 -&gt; 0 -&gt; 7 Solution 1 Use StackUse Stack to save time, but lose space. Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; int len1 = 0, len2 = 0; ListNode dumpy = new ListNode(0); ListNode cur1 = l1, cur2 = l2, cur = dumpy; int c = 0; Stack&lt;ListNode&gt; s = new Stack&lt;ListNode&gt;(); while(cur1 != null)&#123; len1++; cur1 = cur1.next; &#125; while(cur2 != null)&#123; len2++; cur2 = cur2.next; &#125; cur1 = l1; cur2 = l2; s.push(dumpy); if(len1 &gt;= len2)&#123; for(int i =0; i&lt; len1-len2; i++)&#123; cur.next = new ListNode(cur1.val); cur1 = cur1.next; cur = cur.next; s.push(cur); &#125; &#125;else&#123; for(int i =0; i&lt; len2-len1; i++)&#123; cur.next = new ListNode(cur2.val); cur2 = cur2.next; cur = cur.next; s.push(cur); &#125; &#125; while(cur1 != null)&#123; cur.next = new ListNode(cur1.val + cur2.val); s.push(cur.next); cur1 = cur1.next; cur2 = cur2.next; cur = cur.next; &#125; while(s.size()&gt;0)&#123; if(s.peek().val+c&gt;=10)&#123; s.pop().val+=c-10; c=1; &#125;else&#123; s.pop().val+=c; c=0; &#125; &#125; if(dumpy.val == 0) return dumpy.next; return dumpy; &#125; &#125; T&amp;S AnalysisTime: I sanned the list and Stack for constant, so time complexity is O(n). Space: Obviously, O(n), since I used the Stack.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Link List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[328 Odd Even Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F328-Odd-Even-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list, group all odd nodes together followed by the even nodes. Please note here we are talking about the node number and not the value in the nodes. You should try to do it in place. The program should run in O(1) space complexity and O(nodes) time complexity. Example: Given 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, return 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL. Note: The relative order inside both the even and odd groups should remain as it was in the input. The first node is considered odd, the second node even and so on … Solution 1 Pointers TrackingI use three pointers to track the list, and add to the tail according. 1234567891011121314151617181920212223242526272829303132333435363738394041class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return null; ListNode headOdd = new ListNode(0), headEven = new ListNode(0), curOdd = headOdd, curEven = headEven, cur=new ListNode(0), dumpy = cur; cur.next = head; boolean isOdd = false; while(cur != null)&#123; isOdd = !isOdd; cur = cur.next; if(isOdd)&#123; curOdd.next = cur; curOdd = curOdd.next; &#125;else&#123; curEven.next = cur; curEven = curEven.next; &#125; &#125; cur = dumpy; curEven = headEven.next; curOdd = headOdd.next; while(curOdd != null)&#123; cur.next = curOdd; cur = cur.next; curOdd = curOdd.next; &#125; while(curEven != null)&#123; cur.next = curEven; cur = cur.next; curEven = curEven.next; &#125; return dumpy.next; &#125; &#125; T&amp;S AnalysisTime: I sanned the list for constant, so time complexity is O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[237 Delete Node in a Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F237-Delete-Node-in-a-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. Supposed the linked list is 1 -&gt; 2 -&gt; 3 -&gt; 4 and you are given the third node with value 3, the linked list should become 1 -&gt; 2 -&gt; 4 after calling your function. Solution 1 Easy SolutionCode1234567class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(1). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[234 Palindrome Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F234-Palindrome-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list, determine if it is a palindrome. Solution 1 Reverse HalfI reversed the latter half, and compare. Code1234567891011121314151617181920212223242526272829class Solution &#123; public boolean isPalindrome(ListNode head) &#123; ListNode fast = head, slow = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125; slow=reverseList(slow); fast = head; while(slow != null &amp;&amp; fast !=null)&#123; if(slow.val != fast.val) return false; slow = slow.next; fast =fast.next; &#125; return true; &#125; private ListNode reverseList(ListNode p)&#123; ListNode last = null, cur = p, temp; while(cur != null)&#123; temp = cur.next; cur.next = last; last = cur; cur = temp; &#125; return last; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[206 Reverse Linked List]]></title>
    <url>%2F2017%2F08%2F24%2F206-Reverse-Linked-List%2F</url>
    <content type="text"><![CDATA[Question Reverse a singly linked list. Solution 1 Easy solutionToo easy to explain. Code12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode cur = head, last=null, temp; while(cur != null)&#123; temp = cur.next; cur.next = last; last = cur; cur = temp; &#125; return last; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[203 Removed Linked List Elements]]></title>
    <url>%2F2017%2F08%2F24%2F203-Removed-Linked-List-Elements%2F</url>
    <content type="text"><![CDATA[Question Remove all elements from a linked list of integers that have value val. Example Given: 1 –&gt; 2 –&gt; 6 –&gt; 3 –&gt; 4 –&gt; 5 –&gt; 6, val = 6 Return: 1 –&gt; 2 –&gt; 3 –&gt; 4 –&gt; 5 Solution 1 Easy Problem, Easy SolutionNo explanation. Code:123456789101112131415161718class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; ListNode dumpy = new ListNode(0); dumpy.next = head; ListNode p = dumpy; ListNode q; while(p != null &amp;&amp; p.next != null)&#123; q = p; while(p.next!=null &amp;&amp; p.next.val == val) p=p.next; q.next=p.next; p=p.next; &#125; return dumpy.next; &#125;&#125; T&amp;S AnalysisTime: Obviously, O(n). Space: Obviously, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[160 Intersection of Two Linked Lists]]></title>
    <url>%2F2017%2F08%2F24%2F160-Intersection-of-Two-Linked-Lists%2F</url>
    <content type="text"><![CDATA[Question Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: A: a1 → a2 ↘ c1 → c2 → c3 ↗ B: b1 → b2 → b3 begin to intersect at node c1. Notes: If the two linked lists have no intersection at all, return null. The linked lists must retain their original structure after the function returns. Your code should preferably run in O(n) time and use only O(1) memory. Solution 1 Fast and Slow PointersSince we could change the structure in the process, we can make it a circle and usc fast and slow pointers to solve the problem. Code123456789101112131415161718192021222324252627282930313233public class Solution &#123; public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; ListNode fast = headB, slow = headB, p = headA; if(headA == null || headB == null) return null; while(p.next != null) p=p.next; p.next = headA; slow = slow.next; if(slow == null)&#123; p.next = null; return null; &#125; fast = slow.next; while(fast != null &amp;&amp; fast.next != null &amp;&amp; fast != slow)&#123; fast = fast.next.next; slow = slow.next; &#125; if(fast == null || fast.next == null)&#123; p.next =null; return null; &#125; slow =headB; while(fast != slow)&#123; fast = fast.next; slow =slow.next; &#125; p.next = null; return fast; &#125;&#125; T&amp;S AnalysisTime: It only envolve sanning the circle constant times, thus time complexity is O(n). Space: Constant extra Space is used, thus, O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Two Pointers</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148 Sort List]]></title>
    <url>%2F2017%2F08%2F24%2F148-Sort-List%2F</url>
    <content type="text"><![CDATA[Question Sort a linked list in O(n log n) time using constant space complexity. Solution 1 Bottom to TopSince we could only use O(1) extra space, recursive method will not be acceptable. Thus, there is a Bottom-to-Top solution. Its idea is same as merge sort, just it’s not recursive, it is not easy to explain in detail, but the code is below. We need to be careful of boundary problems. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public ListNode sortList(ListNode head) &#123; int length = 0; ListNode left, right, tail, cur; ListNode dumy = new ListNode(0); dumy.next = head; cur = dumy.next; while(cur != null)&#123; length++; cur = cur.next; &#125; for(int step = 1; step &lt; length; step&lt;&lt;=1)&#123; cur = dumy.next; tail = dumy; while(cur != null)&#123; left = cur; right = seperate(left, step); cur = seperate(right, step); tail = merge(left, right, tail); &#125; &#125; return dumy.next; &#125; // seperate the list from the "step" point private ListNode seperate(ListNode head, int step)&#123; ListNode p; for(int i = 1; head != null &amp;&amp; i &lt; step; i++) head = head.next; if(head == null) return null; p = head.next; head.next = null; return p; &#125; // merge two list, add to the "head" and return its tail private ListNode merge(ListNode l1, ListNode l2, ListNode head)&#123; ListNode p = head; while( l1 != null &amp;&amp; l2 != null )&#123; if(l1.val &lt;= l2.val)&#123; p.next = l1; l1 = l1.next; &#125;else&#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if(l1 == null)&#123; p.next = l2; while(l2.next != null) l2 = l2.next; return l2; &#125; else&#123; p.next = l1; while(l1.next != null) l1 = l1.next; return l1; &#125; &#125; T&amp;S AnalysisTime: Obviously, as the problem required, it’s O(nlogn). Space: It’s O(1) for not using recursion.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
        <tag>Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[143 Reorder List]]></title>
    <url>%2F2017%2F08%2F24%2F143-Reorder-List%2F</url>
    <content type="text"><![CDATA[Question Given a singly linked list L: L0?L1?…?Ln-1?Ln, reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?… You must do this in-place without altering the nodes’ values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. Solution 1 Seperate, Reverse and MergeThis solution might seem complicated, but it is in fact fast and require only constant extra space. First, SEPERATE the list into two parts at its middle point. If its length is odd, then the former one should be longer. Second, REVERSE the latter part using the function reverseList. Finally, MERGE the two lists again, and we fot the correct answer. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if(head == null || head.next == null) return; int l = 0, i; ListNode p = head, temp1, temp2, q=p, t; while(p!=null)&#123; l += 1; p = p.next; &#125; p=head; for(i = 0; i &lt; (l-1)/2; i++) q=q.next; t=q; q.next=reverseList(q.next); q=q.next; t.next=null; for(i = 0; i &lt;= (l-1)/2; i++)&#123; if(q == null) return; temp1 = p.next; p.next = q; temp2 = q.next; q.next =temp1; p = temp1; q = temp2; &#125; &#125; public ListNode reverseList( ListNode p)&#123; ListNode head; head = p; ListNode temp = null, q; while(p != null)&#123; head = p; q = p.next; p.next = temp; temp = p; p=q; &#125; return head; &#125;&#125; T&amp;S AnalysisTime: As I said, it is fast enough, since it is only evolved with some scanning operation, thus the time complexity is O(n). Space: Space Complexity is obviously O(1), since only constant extra space is used.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138 Copy List with Random Pointer]]></title>
    <url>%2F2017%2F08%2F23%2F138-Copy-List-with-Random-Pointer%2F</url>
    <content type="text"><![CDATA[QuestionA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Solution 1 Hasp-MapWe have to copy the whole list and random pointers, thus we first copy the next line, meanwhile, push the original : new to haspmap, for convenience of copying the random line. Code12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;(); RandomListNode res = new RandomListNode(0); RandomListNode p = res; RandomListNode q = head; while(q != null)&#123; p.next = new RandomListNode(q.label); map.put(q, p.next); q=q.next; p=p.next; &#125; map.put(null, null); p=res.next; q=head; while(q != null)&#123; p.random=map.get(q.random); p=p.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Hashing inserting and querying operation is so fast that it could be considered as O(1), in this case, since we scanned the linked list two times, time complexity should be O(n). Space: Considering extra space, it is obvious O(n), to build the hash map. Solution 2 Without HashThis method is not accepted, because it has to change the original linked list’s next attribution, but it only cost O(1) Space! Code1234567891011121314151617181920212223242526272829public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; RandomListNode p = head; RandomListNode res = new RandomListNode(0); RandomListNode q = res; RandomListNode temp; while(p != null)&#123; q.next = new RandomListNode(p.label); q.next.random = p.random; temp = p; p=p.next; temp.next = q.next; q=q.next; &#125; q = res.next; while(q != null)&#123; if(q.random != null) q.random = q.random.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Same as above, O(n). Space:Only Constant extra space used, so it’s O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[661 Image Smoother]]></title>
    <url>%2F2017%2F08%2F23%2F661-Image-Smoother%2F</url>
    <content type="text"><![CDATA[Question Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. example: Input:[[1,1,1], [1,0,1], [1,1,1]] Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Solution 1 Temp Array to Save SpaceAs I see the problem, I know that time complexity will not be less than O(row * col). Thus, I try to find a way to save space, which shold have been O(row * col), too. In this solution, I used two temp arraies, temp1 and temp2, see the code below. Code class Solution { public int[][] imageSmoother(int[][] M) { int row = M.length, col = M[0].length; int[] temp1 = new int[row]; int[] temp2 = new int[row]; for(int i = 0; i &lt; row; i++){ temp1[i] = findAve(M, i, 0); } for(int j = 1; j &lt; col; j++){ for(int i = 0; i &lt; row; i++) temp2[i] = findAve(M, i, j); for(int i = 0; i &lt; row; i++){ M[i][j-1]=temp1[i]; temp1[i] = temp2[i]; } } for( int i = 0; i &lt; row; i++) M[i][col-1] = temp1[i]; return M; } public int findAve(int [][] M, int i, int j){ int sum = 0, num = 9; for(int a = i-1; a &lt;= i+1; a++){ for(int b = j-1; b&lt;=j+1; b++){ if((a&lt;0 || a&gt; M.length-1) || (b&lt;0 || b&gt;M[0].length-1)){ num--; }else{ sum+=M[a][b]; } } } return sum/num; } } T&amp;S AnalysisTime: The time complexity should not be lesser, it’s O(row * col). Space: Only constant extra space is used, except the two temp array, thus space complexity is O(row), whic could be turned to O(min(row, col)) by choosing the fewer one, but the code will be much longer.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Space Saving</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[643 Maxium Average Subarray I]]></title>
    <url>%2F2017%2F08%2F23%2F643-Maxium-Average-Subarray-I%2F</url>
    <content type="text"><![CDATA[Question Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. example: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Solution 1 Cumulative ArraySince it’s a contiguous array comparasion, we can first find the sum array, then deduce accordingly to easily find those sums. Code1234567891011121314class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; for(int i = 1; i &lt; nums.length; i++ )&#123; nums[i]+=nums[i-1]; &#125; int max = nums[k-1]; for(int i = 0; i &lt; nums.length-k; i++)&#123; if(nums[i+k] - nums[i] &gt; max) max = nums[i+k] - nums[i]; &#125; return (double)max/k; &#125;&#125; T&amp;S AnalysisTime: Only O(n) because we scanned the array two times. Space: O(1), if we use the orginal array to store the cumulative array.Otherwise, it should be O(n). Solution 2 Window ScanIf we know one continous sum, we can easily find out the next by adding the next number and deducting the head number. Code123456789101112131415161718class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; int maxS = 0; for(int i=0; i &lt; k; i++)&#123; maxS+=nums[i]; &#125; int current = maxS; int head = 0, tail = k-1; while(tail &lt; nums.length-1)&#123; current = current+nums[tail+1]-nums[head]; maxS = Math.max(maxS, current); head++; tail++; &#125; return (double)maxS/k; &#125;&#125; T&amp;S AnalysisTime: Since only scan once, the time complexity is o(n). Space: Constant extra space is used, thus space complexity is O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[628 Maximum Product of Three Numbers]]></title>
    <url>%2F2017%2F08%2F22%2F628-Maximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[Question Given an integer array, find three numbers whose product is maximum and output the maximum product. Example: Input: [1,2,3]Output: 6 Solution 1 SortThere are only 3 possible largest comnination, 2 smallest negative + 1 largest positive, or 3 largest positive, or 3 smallest negative. Thus, sorting first, then it is a very straightforward problem. Code12345678910class Solution &#123; public int maximumProduct(int[] nums) &#123; Arrays.sort(nums); int l = nums.length; int a = nums[0], b = nums[1], c= nums[2], d = nums[l-1], e = nums[l-2], f = nums[l-3]; return Math.max(a*b*c, Math.max(a*b*d, d*e*f)); &#125;&#125; T&amp;S AnalysisTime: Since there is only one sort operation and some constant time operations, its time complexity is O(nlogn), where n represents the length of the array. Space: Space complexity is obviously O(nlogn), since only sorting cost extra space. P.S.Since we only have to find those 5 numbers, we can at most scan the array one time to get them, in this way, we get an O(n) time and O(1) Extra Space solution.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[621 Task Scheduler]]></title>
    <url>%2F2017%2F08%2F22%2F621-Task-Scheduler%2F</url>
    <content type="text"><![CDATA[Question Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. example: Input : tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2 Output : 8 Explanation : A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Solution 1 Max-HeapSince what a charcter is does not affect the result, we only have to ocnsider their counts. Following is an intutional solution, we arrange the largest first, which is to be verify. But it works. So we need a max-heap – a fast way to find the largest. Step 1Store the number of each charaters in a Max-Heap Step 2Loop. One loop contains n steps, each step remove one current largest, if it is still not totally removed, add it to a temp ArrayList. If the queue is empty before n steps, then addidle time interval accordingly. Afterwards, put all elements in the temp array to the queue again. Code:12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if(n==0) return tasks.length; int[] map = new int[26]; int time = 0, i=0; PriorityQueue &lt; Integer &gt; queue = new PriorityQueue &lt; Integer &gt; (26, Collections.reverseOrder()); int intervals=0; for(char c : tasks) map[(int)(c-'A')]++; for(int x : map)&#123; if(x &gt; 0) queue.add(x); &#125; while(queue.size()&gt;0)&#123; i=0; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); while(i &lt;= n)&#123; if(queue.peek()&gt;1) temp.add(queue.poll()-1); else queue.poll(); time++; i++; if(queue.size()==0)&#123; if(temp.size()!=0)&#123; time+=n-i+1; break; &#125; else&#123; return time; &#125; &#125; &#125; for(int x: temp) queue.add(x); &#125; return time; &#125;&#125; T&amp;S AnalysisTime: Since the size of queue is limited under 26, time complexity only depend on n linearly, thus, time complexity is O(n). Space: Space complexity is obviously O(1), because there are at most 26 kinds of characters. Solution 2 Counting Idle TimeThis method first count the minium idle time, then calculate out the result. Code12345678910111213public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - 'A']++; Arrays.sort(map); int max_val = map[25] - 1, idle_slots = max_val * n; for (int i = 24; i &gt;= 0 &amp;&amp; map[i] &gt; 0; i--) &#123; idle_slots -= Math.min(map[i], max_val); &#125; return idle_slots &gt; 0 ? idle_slots + tasks.length : tasks.length; &#125;&#125; T&amp;S AnalysisTime: O(n). It is obvious. Spaece: O(1). Also obvious.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Queue</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog Starts Here]]></title>
    <url>%2F2017%2F08%2F22%2FNew-Article%2F</url>
    <content type="text"><![CDATA[Hi, this is a blog about coding, recoding my learning journey from 2017 summer.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>general</tag>
      </tags>
  </entry>
</search>
