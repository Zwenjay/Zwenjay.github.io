<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[143 Reorder List]]></title>
    <url>%2F2017%2F08%2F24%2F143-Reorder-List%2F</url>
    <content type="text"><![CDATA[QuestionGiven a singly linked list L: L0?L1?…?Ln-1?Ln, reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?… You must do this in-place without altering the nodes’ values. For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. Solution 1 Seperate, Reverse and MergeThis solution might seem complicated, but it is in fact fast and require only constant extra space. First, SEPERATE the list into two parts at its middle point. If its length is odd, then the former one should be longer. Second, REVERSE the latter part using the function reverseList. Finally, MERGE the two lists again, and we fot the correct answer. Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void reorderList(ListNode head) &#123; if(head == null || head.next == null) return; int l = 0, i; ListNode p = head, temp1, temp2, q=p, t; while(p!=null)&#123; l += 1; p = p.next; &#125; p=head; for(i = 0; i &lt; (l-1)/2; i++) q=q.next; t=q; q.next=reverseList(q.next); q=q.next; t.next=null; for(i = 0; i &lt;= (l-1)/2; i++)&#123; if(q == null) return; temp1 = p.next; p.next = q; temp2 = q.next; q.next =temp1; p = temp1; q = temp2; &#125; &#125; public ListNode reverseList( ListNode p)&#123; ListNode head; head = p; ListNode temp = null, q; while(p != null)&#123; head = p; q = p.next; p.next = temp; temp = p; p=q; &#125; return head; &#125;&#125; T&amp;S AnalysisTime: As I said, it is fast enough, since it is only evolved with some scanning operation, thus the time complexity is O(n). Space: Space Complexity is obviously O(1), since only constant extra space is used.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Linked Lisr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[138 Copy List with Random Pointer]]></title>
    <url>%2F2017%2F08%2F23%2F138-Copy-List-with-Random-Pointer%2F</url>
    <content type="text"><![CDATA[QuestionA linked list is given such that each node contains an additional random pointer which could point to any node in the list or null. Return a deep copy of the list. Solution 1 Hasp-MapWe have to copy the whole list and random pointers, thus we first copy the next line, meanwhile, push the original : new to haspmap, for convenience of copying the random line. Code12345678910111213141516171819202122232425262728293031323334353637/** * Definition for singly-linked list with a random pointer. * class RandomListNode &#123; * int label; * RandomListNode next, random; * RandomListNode(int x) &#123; this.label = x; &#125; * &#125;; */public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;&gt;(); RandomListNode res = new RandomListNode(0); RandomListNode p = res; RandomListNode q = head; while(q != null)&#123; p.next = new RandomListNode(q.label); map.put(q, p.next); q=q.next; p=p.next; &#125; map.put(null, null); p=res.next; q=head; while(q != null)&#123; p.random=map.get(q.random); p=p.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Hashing inserting and querying operation is so fast that it could be considered as O(1), in this case, since we scanned the linked list two times, time complexity should be O(n). Space: Considering extra space, it is obvious O(n), to build the hash map. Solution 2 Without HashThis method is not accepted, because it has to change the original linked list’s next attribution, but it only cost O(1) Space! Code1234567891011121314151617181920212223242526272829public class Solution &#123; public RandomListNode copyRandomList(RandomListNode head) &#123; if(head==null) return null; RandomListNode p = head; RandomListNode res = new RandomListNode(0); RandomListNode q = res; RandomListNode temp; while(p != null)&#123; q.next = new RandomListNode(p.label); q.next.random = p.random; temp = p; p=p.next; temp.next = q.next; q=q.next; &#125; q = res.next; while(q != null)&#123; if(q.random != null) q.random = q.random.next; q=q.next; &#125; return res.next; &#125;&#125; T&amp;S AnalysisTime: Same as above, O(n). Space:Only Constant extra space used, so it’s O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Hash Table</tag>
        <tag>Linked List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[661 Image Smoother]]></title>
    <url>%2F2017%2F08%2F23%2F661-Image-Smoother%2F</url>
    <content type="text"><![CDATA[Question Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. example: Input:[[1,1,1], [1,0,1], [1,1,1]] Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]] Explanation: For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0 For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0 For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Solution 1 Temp Array to Save SpaceAs I see the problem, I know that time complexity will not be less than O(row * col). Thus, I try to find a way to save space, which shold have been O(row * col), too. In this solution, I used two temp arraies, temp1 and temp2, see the code below. Code class Solution { public int[][] imageSmoother(int[][] M) { int row = M.length, col = M[0].length; int[] temp1 = new int[row]; int[] temp2 = new int[row]; for(int i = 0; i &lt; row; i++){ temp1[i] = findAve(M, i, 0); } for(int j = 1; j &lt; col; j++){ for(int i = 0; i &lt; row; i++) temp2[i] = findAve(M, i, j); for(int i = 0; i &lt; row; i++){ M[i][j-1]=temp1[i]; temp1[i] = temp2[i]; } } for( int i = 0; i &lt; row; i++) M[i][col-1] = temp1[i]; return M; } public int findAve(int [][] M, int i, int j){ int sum = 0, num = 9; for(int a = i-1; a &lt;= i+1; a++){ for(int b = j-1; b&lt;=j+1; b++){ if((a&lt;0 || a&gt; M.length-1) || (b&lt;0 || b&gt;M[0].length-1)){ num--; }else{ sum+=M[a][b]; } } } return sum/num; } } T&amp;S AnalysisTime: The time complexity should not be lesser, it’s O(row * col). Space: Only constant extra space is used, except the two temp array, thus space complexity is O(row), whic could be turned to O(min(row, col)) by choosing the fewer one, but the code will be much longer.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Space Saving</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[643 Maxium Average Subarray I]]></title>
    <url>%2F2017%2F08%2F23%2F643-Maxium-Average-Subarray-I%2F</url>
    <content type="text"><![CDATA[Question Given an array consisting of n integers, find the contiguous subarray of given length k that has the maximum average value. And you need to output the maximum average value. example: Input: [1,12,-5,-6,50,3], k = 4 Output: 12.75 Explanation: Maximum average is (12-5-6+50)/4 = 51/4 = 12.75 Solution 1 Cumulative ArraySince it’s a contiguous array comparasion, we can first find the sum array, then deduce accordingly to easily find those sums. Code1234567891011121314class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; for(int i = 1; i &lt; nums.length; i++ )&#123; nums[i]+=nums[i-1]; &#125; int max = nums[k-1]; for(int i = 0; i &lt; nums.length-k; i++)&#123; if(nums[i+k] - nums[i] &gt; max) max = nums[i+k] - nums[i]; &#125; return (double)max/k; &#125;&#125; T&amp;S AnalysisTime: Only O(n) because we scanned the array two times. Space: O(1), if we use the orginal array to store the cumulative array.Otherwise, it should be O(n). Solution 2 Window ScanIf we know one continous sum, we can easily find out the next by adding the next number and deducting the head number. Code123456789101112131415161718class Solution &#123; public double findMaxAverage(int[] nums, int k) &#123; int maxS = 0; for(int i=0; i &lt; k; i++)&#123; maxS+=nums[i]; &#125; int current = maxS; int head = 0, tail = k-1; while(tail &lt; nums.length-1)&#123; current = current+nums[tail+1]-nums[head]; maxS = Math.max(maxS, current); head++; tail++; &#125; return (double)maxS/k; &#125;&#125; T&amp;S AnalysisTime: Since only scan once, the time complexity is o(n). Space: Constant extra space is used, thus space complexity is O(1).]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[628 Maximum Product of Three Numbers]]></title>
    <url>%2F2017%2F08%2F22%2F628-Maximum-Product-of-Three-Numbers%2F</url>
    <content type="text"><![CDATA[Question Given an integer array, find three numbers whose product is maximum and output the maximum product. Example: Input: [1,2,3]Output: 6 Solution 1 SortThere are only 3 possible largest comnination, 2 smallest negative + 1 largest positive, or 3 largest positive, or 3 smallest negative. Thus, sorting first, then it is a very straightforward problem. Code12345678910class Solution &#123; public int maximumProduct(int[] nums) &#123; Arrays.sort(nums); int l = nums.length; int a = nums[0], b = nums[1], c= nums[2], d = nums[l-1], e = nums[l-2], f = nums[l-3]; return Math.max(a*b*c, Math.max(a*b*d, d*e*f)); &#125;&#125; T&amp;S AnalysisTime: Since there is only one sort operation and some constant time operations, its time complexity is O(nlogn), where n represents the length of the array. Space: Space complexity is obviously O(nlogn), since only sorting cost extra space. P.S.Since we only have to find those 5 numbers, we can at most scan the array one time to get them, in this way, we get an O(n) time and O(1) Extra Space solution.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[621 Task Scheduler]]></title>
    <url>%2F2017%2F08%2F22%2F621-Task-Scheduler%2F</url>
    <content type="text"><![CDATA[Question Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks.Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle. However, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle. You need to return the least number of intervals the CPU will take to finish all the given tasks. example: Input : tasks = [‘A’,’A’,’A’,’B’,’B’,’B’], n = 2 Output : 8 Explanation : A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B. Solution 1 Max-HeapSince what a charcter is does not affect the result, we only have to ocnsider their counts. Following is an intutional solution, we arrange the largest first, which is to be verify. But it works. So we need a max-heap – a fast way to find the largest. Step 1Store the number of each charaters in a Max-Heap Step 2Loop. One loop contains n steps, each step remove one current largest, if it is still not totally removed, add it to a temp ArrayList. If the queue is empty before n steps, then addidle time interval accordingly. Afterwards, put all elements in the temp array to the queue again. Code:12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; if(n==0) return tasks.length; int[] map = new int[26]; int time = 0, i=0; PriorityQueue &lt; Integer &gt; queue = new PriorityQueue &lt; Integer &gt; (26, Collections.reverseOrder()); int intervals=0; for(char c : tasks) map[(int)(c-'A')]++; for(int x : map)&#123; if(x &gt; 0) queue.add(x); &#125; while(queue.size()&gt;0)&#123; i=0; List&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); while(i &lt;= n)&#123; if(queue.peek()&gt;1) temp.add(queue.poll()-1); else queue.poll(); time++; i++; if(queue.size()==0)&#123; if(temp.size()!=0)&#123; time+=n-i+1; break; &#125; else&#123; return time; &#125; &#125; &#125; for(int x: temp) queue.add(x); &#125; return time; &#125;&#125; T&amp;S AnalysisTime: Since the size of queue is limited under 26, time complexity only depend on n linearly, thus, time complexity is O(n). Space: Space complexity is obviously O(1), because there are at most 26 kinds of characters. Solution 2 Counting Idle TimeThis method first count the minium idle time, then calculate out the result. Code12345678910111213public class Solution &#123; public int leastInterval(char[] tasks, int n) &#123; int[] map = new int[26]; for (char c: tasks) map[c - 'A']++; Arrays.sort(map); int max_val = map[25] - 1, idle_slots = max_val * n; for (int i = 24; i &gt;= 0 &amp;&amp; map[i] &gt; 0; i--) &#123; idle_slots -= Math.min(map[i], max_val); &#125; return idle_slots &gt; 0 ? idle_slots + tasks.length : tasks.length; &#125;&#125; T&amp;S AnalysisTime: O(n). It is obvious. Spaece: O(1). Also obvious.]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Array</tag>
        <tag>Queue</tag>
        <tag>Greedy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My Blog Starts Here]]></title>
    <url>%2F2017%2F08%2F22%2FNew-Article%2F</url>
    <content type="text"><![CDATA[Hi, this is a blog about coding, recoding my learning journey from 2017 summer.]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>general</tag>
      </tags>
  </entry>
</search>
